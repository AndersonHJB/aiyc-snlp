
Read Martin Luther King Jr.'s 'I Have a Dream' speech in its entirety
Updated January 14, 20221:53 PM ET
Heard on Talk of the Nation
17-Minute Listen
Download
Transcript

Civil rights leader Martin Luther King Jr. addresses the crowd at the Lincoln Memorial in Washington, D.C., where he gave his "I Have a Dream" speech on Aug. 28, 1963, as part of the March on Washington.
AFP via Getty Images
Monday marks the birthday of Martin Luther King Jr. Below is a transcript of his celebrated "I Have a Dream" speech, delivered on Aug. 28, 1963, on the steps of the Lincoln Memorial. NPR's Talk of the Nation aired the speech in 2010 — listen to that broadcast at the audio link above.


Martin Luther King Jr. and other civil rights leaders gather before a rally at the Lincoln Memorial on Aug. 28, 1963, in Washington.
National Archives/Hulton Archive via Getty Images
Rev. Martin Luther King Jr.: Five score years ago, a great American, in whose symbolic shadow we stand today, signed the Emancipation Proclamation. This momentous decree came as a great beacon light of hope to millions of Negro slaves who had been seared in the flames of withering injustice. It came as a joyous daybreak to end the long night of their captivity.

But 100 years later, the Negro still is not free. One hundred years later, the life of the Negro is still sadly crippled by the manacles of segregation and the chains of discrimination. One hundred years later, the Negro lives on a lonely island of poverty in the midst of a vast ocean of material prosperity. One hundred years later the Negro is still languished in the corners of American society and finds himself in exile in his own land. And so we've come here today to dramatize a shameful condition. In a sense we've come to our nation's capital to cash a check.

The Power Of Martin Luther King Jr.'s Anger
CODE SWITCH
The Power Of Martin Luther King Jr.'s Anger
When the architects of our republic wrote the magnificent words of the Constitution and the Declaration of Independence, they were signing a promissory note to which every American was to fall heir. This note was a promise that all men — yes, Black men as well as white men — would be guaranteed the unalienable rights of life, liberty and the pursuit of happiness.

It is obvious today that America has defaulted on this promissory note insofar as her citizens of color are concerned. Instead of honoring this sacred obligation, America has given the Negro people a bad check, a check which has come back marked insufficient funds.

But we refuse to believe that the bank of justice is bankrupt.

We refuse to believe that there are insufficient funds in the great vaults of opportunity of this nation. And so we've come to cash this check, a check that will give us upon demand the riches of freedom and the security of justice.

We have also come to his hallowed spot to remind America of the fierce urgency of now. This is no time to engage in the luxury of cooling off or to take the tranquilizing drug of gradualism.


Civil rights protesters march from the Washington Monument to the Lincoln Memorial for the March on Washington on Aug. 28, 1963.
Kurt Severin/Three Lions/Hulton Archive/Getty Images
Now is the time to make real the promises of democracy. Now is the time to rise from the dark and desolate valley of segregation to the sunlit path of racial justice. Now is the time to lift our nation from the quick sands of racial injustice to the solid rock of brotherhood. Now is the time to make justice a reality for all of God's children.

It would be fatal for the nation to overlook the urgency of the moment. This sweltering summer of the Negro's legitimate discontent will not pass until there is an invigorating autumn of freedom and equality. 1963 is not an end, but a beginning. Those who hope that the Negro needed to blow off steam and will now be content will have a rude awakening if the nation returns to business as usual.

There will be neither rest nor tranquility in America until the Negro is granted his citizenship rights. The whirlwinds of revolt will continue to shake the foundations of our nation until the bright day of justice emerges.

But there is something that I must say to my people who stand on the warm threshold which leads into the palace of justice. In the process of gaining our rightful place, we must not be guilty of wrongful deeds. Let us not seek to satisfy our thirst for freedom by drinking from the cup of bitterness and hatred.

Bayard Rustin: The Man Behind the March on Washington (2021)
THROUGHLINE
Bayard Rustin: The Man Behind the March on Washington (2021)
We must forever conduct our struggle on the high plane of dignity and discipline. We must not allow our creative protest to degenerate into physical violence. Again and again, we must rise to the majestic heights of meeting physical force with soul force. The marvelous new militancy which has engulfed the Negro community must not lead us to a distrust of all white people, for many of our white brothers, as evidenced by their presence here today, have come to realize that their destiny is tied up with our destiny.

And they have come to realize that their freedom is inextricably bound to our freedom. We cannot walk alone. And as we walk, we must make the pledge that we shall always march ahead. We cannot turn back.

There are those who are asking the devotees of civil rights, when will you be satisfied? We can never be satisfied as long as the Negro is the victim of the unspeakable horrors of police brutality. We can never be satisfied as long as our bodies, heavy with the fatigue of travel, cannot gain lodging in the motels of the highways and the hotels of the cities.

We cannot be satisfied as long as the Negro's basic mobility is from a smaller ghetto to a larger one. We can never be satisfied as long as our children are stripped of their selfhood and robbed of their dignity by signs stating: for whites only.

We cannot be satisfied as long as a Negro in Mississippi cannot vote and a Negro in New York believes he has nothing for which to vote.

No, no, we are not satisfied, and we will not be satisfied until justice rolls down like waters, and righteousness like a mighty stream.

How The Voting Rights Act Came To Be And How It's Changed
POLITICS
How The Voting Rights Act Came To Be And How It's Changed
I am not unmindful that some of you have come here out of great trials and tribulations. Some of you have come fresh from narrow jail cells. Some of you have come from areas where your quest for freedom left you battered by the storms of persecution and staggered by the winds of police brutality. You have been the veterans of creative suffering. Continue to work with the faith that unearned suffering is redemptive. Go back to Mississippi, go back to Alabama, go back to South Carolina, go back to Georgia, go back to Louisiana, go back to the slums and ghettos of our Northern cities, knowing that somehow this situation can and will be changed.

Let us not wallow in the valley of despair, I say to you today, my friends.

So even though we face the difficulties of today and tomorrow, I still have a dream. It is a dream deeply rooted in the American dream. I have a dream that one day this nation will rise up and live out the true meaning of its creed: We hold these truths to be self-evident, that all men are created equal.


People clap and sing along to a freedom song between speeches at the March on Washington for Jobs and Freedom in 1963.
Express Newspapers via Getty Images
I have a dream that one day on the red hills of Georgia, the sons of former slaves and the sons of former slave owners will be able to sit down together at the table of brotherhood.

I have a dream that one day even the state of Mississippi, a state sweltering with the heat of injustice, sweltering with the heat of oppression will be transformed into an oasis of freedom and justice.

I have a dream that my four little children will one day live in a nation where they will not be judged by the color of their skin but by the content of their character. I have a dream today.

I have a dream that one day down in Alabama with its vicious racists, with its governor having his lips dripping with the words of interposition and nullification, one day right down in Alabama little Black boys and Black girls will be able to join hands with little white boys and white girls as sisters and brothers. I have a dream today.

I have a dream that one day every valley shall be exalted, every hill and mountain shall be made low, the rough places will be made plain, and the crooked places will be made straight, and the glory of the Lord shall be revealed, and all flesh shall see it together.

CODE SWITCH
Nikole Hannah-Jones on the power of collective memory
This is our hope. This is the faith that I go back to the South with. With this faith, we will be able to hew out of the mountain of despair a stone of hope. With this faith we will be able to transform the jangling discords of our nation into a beautiful symphony of brotherhood. With this faith we will be able to work together, to pray together, to struggle together, to go to jail together, to stand up for freedom together, knowing that we will be free one day.

This will be the day when all of God's children will be able to sing with new meaning: My country, 'tis of thee, sweet land of liberty, of thee I sing. Land where my fathers died, land of the pilgrims' pride, from every mountainside, let freedom ring.

And if America is to be a great nation, this must become true. And so let freedom ring from the prodigious hilltops of New Hampshire. Let freedom ring from the mighty mountains of New York. Let freedom ring from the heightening Alleghenies of Pennsylvania. Let freedom ring from the snowcapped Rockies of Colorado. Let freedom ring from the curvaceous slopes of California. But not only that, let freedom ring from Stone Mountain of Georgia. Let freedom ring from Lookout Mountain of Tennessee. Let freedom ring from every hill and molehill of Mississippi. From every mountainside, let freedom ring.

And when this happens, and when we allow freedom ring, when we let it ring from every village and every hamlet, from every state and every city, we will be able to speed up that day when all of God's children, Black men and white men, Jews and Gentiles, Protestants and Catholics, will be able to join hands and sing in the words of the old Negro spiritual: Free at last. Free at last. Thank God almighty, we are free at last.
from aiyc1v1 import DataManager, SimpleSearch
path = "/Users/huangjiabao/GitHub/MacBookPro16-Code/PythonCoder/StudentCoder/01_WillQX/Project/00/Prototypes-MP-GUI_Prototype/flask-server/python-src/Analysis.py"
data = DataManager(path).postfix()
from aiyc1v1 import Simple_NlP
# Sid = Simple_NlP(path="I_have_a_Dream.txt", filename="demo.html").main()

# num = 1.0
# print(type(num))
# print(num)


# str 字符串
str_content = "Hello AndersonHJB"
print(type(str_content))
# 见名知意
print(str_content)
# 1、有序性
# l    o    v    e  y    o    u
# 0    1    2    3456    7    8「从左到右」
# -9   -8   -7 -6-5-4-3  -2   -1  「从右到左」
# 下标
# 2、不可变性
# 3、任意数据类型/只要你键盘能输入的，都可以放入字符串中

# list 列表
lst = [1, "Austin", 2.0, "Jaden", (1, 2, 3, 4)]
# 1、有序性
# [1, "Austin", 2.0, "Jaden"]
#  0      1      2      3「从左到右」
# -4     -3     -2     -1 「从右到左」
# 2、可变性
# 列表被创建出来之后，可以被修改、删除、添加等操作
# 3、任意数据类型
# Python 的所有数据类型，均可放入。原本是什么类型，放进去后，还是什么类型——类似与于：书架
# n = 1

# 元组 tuple
t = (1, "Austin", 1.0, "book", [1, 2, 3, 4])
print(t)
print(type(t))
# 1、有序性
# 2、不可变
# 3、任意数据类型

# 字典 dict
d = {"name": "Austin", "age": 19, "key": "value"}
print(type(d))
print(d)
# 1、key: value
# 2、 key-> 钥匙🔑，能变形吗？-> 不能变形「不可变」：key 是要求不可变的数据类型
# 3、value 任意数据类型
# 4、无序的、python3.6+ 之后 字典是有序的，但是平时所说的有序，你目前用不到
# 1、列表、元组可以做key 吗？
# 2、真的 value 是任意数据类型吗？
d = {(1, 2, 3, 4): "list", "name": "AndersonHJB", 1: 12, "name1": [1, 2, 3]}
print(d)

# set 集合
s = {1, 2, 2, 2, 2, 2, 4, 6, (1, 2)}
print(s)
# 1、确定性
# 2、互异性
# 3、无序性
# PS：列表可变，可变造就了未知性与可变性
lst = [1, 2, 3, 3, 3, 4, 5, 6, 7]
s = set(lst)
print(s)

t = tuple(lst)
print(t)

string = str(lst)
print(string)

# d = dict(lst)
lst = [("name", "Austin"), ("age", 19)]
d = dict(lst)
print(d)

# 布尔型 bool
bool_true = True
bool_false = False
print(bool_false)
print(bool_true)

a = 91























print(a // 10 + a % 10)
print(a % 10 * 10 + a // 10)

# a = 1
# print(a + 10)
# print(a)
# a = a + 10
# print(a)
a = 1
a = a + 10
print(a)

b = 1
b += 10  # b = b + 10
print(b)

a = 1
b = 1
r = a + b
print(r)

a = 1.0
b = 1
r = a + b
print(r)

a = 2.0
b = 1
r = a - b
print(r)

a = 2
b = 1
r = a - b
print(r)

a = 2
b = 1
r = a * b
print(r)

a = 2
b = 1
r = a / b
print(r)
# print(a / b)
# print((1 + 1.0))

# a = 25
# Q1: 个位和十位相加 -> 2 + 5 = 7
# Q2: 25 52、41 14
# Q3: 在三位数的情况下，如何处理

a = 25
gewei = a % 10
shiwei = a // 10
r = gewei + shiwei
print(r)
print(gewei, shiwei, sep="", end="")  # 形，用不到这个 value，同时输出
# 你要用到 52，用的了
revers = gewei * 10 + shiwei
print(revers)
r = revers + 1
print(r)











boolean_1 = 1
boolean_2 = 2
r = boolean_2 > boolean_1
print(r)

print(boolean_2 < boolean_1)
print(1 < 2)
print(1 == 1)

import re

html = '''<div id="songs-list">
    <h2 class="title">经典老歌</h2>
    <p class="introduction">
        经典老歌列表
    </p>
    <ul id="list" class="list-group">
        <li data-view="2">一路上有你</li>
        <li data-view="7">
            <a href="/2.mp3" singer="任贤齐">沧海一声笑</a>
        </li>
        <li data-view="4" class="active">
            <a href="/3.mp3" singer="齐秦">往事随风</a>
        </li>
        <li data-view="6"><a href="/4.mp3" singer="beyond">光辉岁月</a></li>
        <li data-view="5"><a href="/5.mp3" singer="陈慧琳">记事本</a></li>
        <li data-view="5">
            <a href="/6.mp3" singer="邓丽君"><i class="fa fa-user"></i>但愿人长久</a>
        </li>
    </ul>
</div>'''
# pattern = '<li.*?active.*?singer="(\w+)">(\w+)</a>'
pattern = '<a.*?>(?:<i.*?</i>)*(.*?)</a>'
result = re.findall(pattern, html, re.S)
# result = re.search('<li.*?active.*?singer="(.*?)">(.*?)</a>', html, re.S)
# print(result.groups())
if result:
    for i in result:
        print(i)
#     # print(result.group(1, 2))

import requests
import re
from requests.exceptions import RequestException
from urllib.parse import urljoin

BASE = "https://bornforthis.cn/web_runing/crawler/regex/"


def requests_fun(url, binary=False):
    try:
        response = requests.get(url)
        if response.status_code == 200:
            if binary:
                return response.content
            else:
                return response.text
        return None
    except RequestException as e:
        return None


def save_music(path, binary):
    with open(path, "wb") as f:
        f.write(binary)


def parse(html):
    pattern = '<a.*?href="(.*?)".*?</a>'
    result = re.findall(pattern, html)
    return result


def joint(url_lst):
    url_list = []
    for url in url_lst:
        url = urljoin(BASE, url)
        url_list.append(url)
    return url_list


def postfix(url):
    music_name = url.split("/")[-1]
    return music_name


def main():
    url = "https://bornforthis.cn/web_runing/crawler/regex/index.html"
    html = requests_fun(url)
    # url_lst = parse(html)
    url_list = joint(parse(html))
    # print(url_list)
    for url in url_list:
        # print(url)
        binary_content = requests_fun(url, binary=True)
        # print(binary_content)
        save_music(f"data/music/{postfix(url)}", binary_content)


if __name__ == '__main__':
    main()






import random

player01_name = input("请输入玩家1号的名称")
player02_name = input("请输入玩家2号的名称")


# ----------------玩家初始信息------------------
class player():
    def __init__(self):
        self.health_point = 500

    def Attack_judge(self, name):
        input_text = True
        while input_text:
            attack_pattern = input(f"{name}请输入想要攻击的方式，输入“攻击”或者“防守”")
            if attack_pattern == "攻击" or "防守":
                input_text = False
            else:
                print("输入有误，请重新输入")
        return attack_pattern


player01 = player()
player02 = player()

# ---------------初始化---------------------
print("游戏即将开始。")
print(f"第一回合内{player01_name}，{player01_name}可以选择攻击或者防御，当选择防御时，{player01_name}在下一回合受到的攻击为实际伤害的十分之一")
print(f"首先请{player01_name}开始攻击")
i = True
while i:
    if player01.health_point <= 0 or player02.health_point <= 0:
        i = False
    else:
        attack_pattern_01 = player01.Attack_judge(player01_name)
        attack_pattern_02 = player02.Attack_judge(player02_name)
        # ---------------判断----------------
        # ---------------玩家1防御玩家2攻击-----------------
        if attack_pattern_01 == "防御" and attack_pattern_02 == "攻击":
            damage_02 = random.randint(50, 100)
            player01_name.health_point -= damage_02 // 10
            print(f"当前{player01_name}的血量为{player01.health_point}\n{player02_name}的血量为{player02.health_point}")
        # ---------------玩家1攻击玩家2防守-----------------
        elif attack_pattern_02 == "防御" and attack_pattern_01 == "攻击":
            damage_01 = random.randint(50, 100)
            player02.health_point -= damage_01 // 10
            print(f"当前{player01_name}的血量为{player01.health_point}\n{player02_name}的血量为{player02.health_point}")
        # ---------------玩家1攻击玩家2攻击-----------------
        elif attack_pattern_01 == "攻击" and attack_pattern_02 == "攻击":
            damage_01 = random.randint(50, 100)
            damage_02 = random.randint(50, 100)
            player01.health_point -= damage_02
            player02.health_point -= damage_01
            print(f"当前{player01_name}的血量为{player01.health_point}\n{player02_name}的血量为{player02.health_point}")
        # --------------玩家1防御玩家2防御------------------
        else:
            print("此轮攻击未造成双方血量减少")
# ---------------结果--------------
if player01.health_point <= 0 or player02.health_point >= 0:
    print(f"{player02_name}获胜。")
elif player01.health_point >= 0 or player02.health_point <= 0:
    print(f"{player01_name}获胜。")
else:
    print("双方平局")

import random

player01_name = input("请输入玩家1号的名称")
player02_name = input("请输入玩家2号的名称")


# ----------------玩家初始信息------------------
class player():
    def __init__(self):
        self.health_point = 100

    def Attack_or_Defence(self, name):
        input_text = True
        while input_text:
            attack_pattern = input(f"{name}请输入想要A的方式，输入“A”或者“D”")
            if attack_pattern == "A" or "D":
                input_text = False
            else:
                print("输入有误，请重新输入")
        return attack_pattern


# def Attack_or_Defence(name):
#     input_text = True
#     while input_text:
#         attack_pattern = input(f"{name}请输入想要A的方式，输入“A”或者“D”")
#         if attack_pattern == "A" or "D":
#             input_text = False
#         else:
#             print("输入有误，请重新输入")
#     return attack_pattern


player01 = player()
player02 = player()

# ---------------初始化---------------------
print("游戏即将开始。")
print(
    f"第一回合内{player01_name}，{player01_name}可以选择A或者防御，当选择防御时，{player01_name}在下一回合受到的A为实际伤害的十分之一")
print(f"首先请{player01_name}开始A")
i = True
while i:
    if player01.health_point <= 0 or player02.health_point <= 0:
        i = False
    damage = random.randint(50, 100)
    # attack_pattern_01 = Attack_or_Defence(player01_name)
    # attack_pattern_02 = Attack_or_Defence(player02_name)
    attack_pattern_01 = player01.Attack_or_Defence(name=player01_name)
    attack_pattern_02 = player01.Attack_or_Defence(name=player02_name)
    # input_text = True
    # while input_text:
    #     attack_pattern_01 = input(f"{player01_name}请输入想要A的方式，输入“A”或者“D”")
    #     if attack_pattern_01 == "A" or "D":
    #         input_text = False
    #     else:
    #         print("输入有误，请重新输入")
    # input_text = True
    # while input_text:
    #     attack_pattern_02 = input(f"{player02_name}请输入想要A的方式，输入“A”或者“D”")
    #     if attack_pattern_02 == "A" or "D":
    #         input_text = False
    #     else:
    #         print("输入有误，请重新输入")
    # ---------------判断----------------
    # ---------------玩家1防御玩家2A-----------------
    if attack_pattern_01 == "D" and attack_pattern_02 == "A":
        damage_02 = random.randint(50, 100)
        player01_name.health_point -= damage_02 // 10
        print(f"当前{player01_name}的血量为{player01.health_point}\n{player02_name}的血量为{player02.health_point}")
    # ---------------玩家1A玩家2D-----------------
    elif attack_pattern_02 == "防御" and attack_pattern_01 == "A":
        damage_01 = random.randint(50, 100)
        player02.health_point -= damage_01 // 10
        print(f"当前{player01_name}的血量为{player01.health_point}\n{player02_name}的血量为{player02.health_point}")
    # ---------------玩家1A玩家2A-----------------
    elif attack_pattern_01 == "A" and attack_pattern_02 == "A":
        damage_01 = random.randint(50, 100)
        damage_02 = random.randint(50, 100)
        player01.health_point -= damage_02
        player02.health_point -= damage_01
        print(f"当前{player01_name}的血量为{player01.health_point}\n{player02_name}的血量为{player02.health_point}")
    # --------------玩家1防御玩家2防御------------------
    else:
        print("此轮A未造成双方血量减少")
# ---------------结果--------------
if player01.health_point <= 0 or player02.health_point >= 0:
    print(f"{player02_name}获胜。")
elif player01.health_point >= 0 or player02.health_point <= 0:
    print(f"{player01_name}获胜。")
else:
    print("双方平局")


class Animals():
    def __init__(self):
        self.x = 0
dog = Animals()
print(dog.x)
import random

player01 = input("请输入玩家1号的名称")
player02 = input("请输入玩家2号的名称")


# ----------------玩家初始信息------------------
class player():
    def __init__(self):
        self.health_point = 500


player01 = player()
player02 = player()

# ---------------初始化---------------------
print("游戏即将开始。")
print(f"第一回合内{player01}，{player01}可以选择攻击或者防御，当选择防御时，{player01}在下一回合受到的攻击为实际伤害的十分之一")
print(f"首先请{player01}开始攻击")
i = True
while i:
    if player01.health_point <= 0 or player02.health_point <= 0:
        i = False
    damage = random.randint(50, 100)
    input_text = True
    while input_text:
        attack_pattern_01 = input(f"{player01}请输入想要攻击的方式，输入“攻击”或者“防守”")
        if attack_pattern_01 == "攻击" or "防守":
            input_text = False
        else:
            print("输入有误，请重新输入")
    input_text = True
    while input_text:
        attack_pattern_02 = input(f"{player02}请输入想要攻击的方式，输入“攻击”或者“防守”")
        if attack_pattern_02 == "攻击" or "防守":
            input_text = False
        else:
            print("输入有误，请重新输入")
    # ---------------判断----------------
    # ---------------玩家1防御玩家2攻击-----------------
    if attack_pattern_01 == "防御" and attack_pattern_02 == "攻击":
        damage_02 = random.randint(50, 100)
        player01.health_point -= damage_02 // 10
        print(f"当前{player01}的血量为"
              f"{player01.health_point}\n{player02}"
              f"的血量为{player02.health_point}")
    # ---------------玩家1攻击玩家2防守-----------------
    elif attack_pattern_02 == "防御" and attack_pattern_01 == "攻击":
        damage_01 = random.randint(50, 100)
        player02.health_point -= damage_01 // 10
        print(f"当前{player01}的血量为{player01.health_point}\n{player02}的血量为{player02.health_point}")
    # ---------------玩家1攻击玩家2攻击-----------------
    elif attack_pattern_01 == "攻击" and attack_pattern_02 == "攻击":
        damage_01 = random.randint(50, 100)
        damage_02 = random.randint(50, 100)
        player01.health_point -= damage_02
        player02.health_point -= damage_01
        print(f"当前{player01}的血量为{player01.health_point}\n{player02}的血量为{player02.health_point}")
    # --------------玩家1防御玩家2防御------------------
    else:
        print("此轮攻击未造成双方血量减少")

# author: look
import random

player01_name = input("请输入玩家1号的名称")
player02_name = input("请输入玩家2号的名称")


# ----------------玩家初始信息------------------
class player():
    def __init__(self):
        self.health_point = 500


player01 = player()  # 实例化
player02 = player()

# ---------------初始化---------------------
print("游戏即将开始。")
print(f"第一回合内{player01}，{player01}可以选择攻击或者防御，当选择防御时，{player01}在下一回合受到的攻击为实际伤害的十分之一")
print(f"首先请{player01}开始攻击")
i = True
while i:
    if player01.health_point <= 0 or player02.health_point <= 0:
        i = False
    damage = random.randint(50, 100)
    input_text = True
    while input_text:
        attack_pattern_01 = input(f"{player01}请输入想要攻击的方式，输入“攻击”或者“防守”")
        if attack_pattern_01 == "攻击" or "防守":
            input_text = False
        else:
            print("输入有误，请重新输入")
    input_text = True
    while input_text:
        attack_pattern_02 = input(f"{player02}请输入想要攻击的方式，输入“攻击”或者“防守”")
        if attack_pattern_02 == "攻击" or "防守":
            input_text = False
        else:
            print("输入有误，请重新输入")
    # ---------------判断----------------
    # ---------------玩家1防御玩家2攻击-----------------
    if attack_pattern_01 == "防御" and attack_pattern_02 == "攻击":
        damage_02 = random.randint(50, 100)
        player01.health_point -= damage_02 // 10
        print(f"当前{player01}的血量为{player01.health_point}\n{player02}的血量为{player02.health_point}")
    # ---------------玩家1攻击玩家2防守-----------------
    elif attack_pattern_02 == "防御" and attack_pattern_01 == "攻击":
        damage_01 = random.randint(50, 100)
        player02.health_point -= damage_01 // 10
        print(f"当前{player01}的血量为{player01.health_point}\n{player02}的血量为{player02.health_point}")
    # ---------------玩家1攻击玩家2攻击-----------------
    elif attack_pattern_01 == "攻击" and attack_pattern_02 == "攻击":
        damage_01 = random.randint(50, 100)
        damage_02 = random.randint(50, 100)
        player01.health_point -= damage_02
        player02.health_point -= damage_01
        print(f"当前{player01}的血量为{player01.health_point}\n{player02}的血量为{player02.health_point}")
    # --------------玩家1防御玩家2防御------------------
    else:
        print("此轮攻击未造成双方血量减少")
# ---------------结果--------------
if player01.health_point <= 0 or player02.health_point >= 0:
    print(f"{player02}获胜。")
elif player01.health_point >= 0 or player02.health_point <= 0:
    print(f"{player01}获胜。")
else:
    print("双方平局")


import platform
import os
import sys
import time


def main():
    content = "你好，我是悦创。。。"
    while True:
        # 清理屏幕输出
        if platform.system().lower() == "windows":
            os.system("cls")
        elif 'ipykernel' in sys.modules:
            from IPython.display import clear_output as clear
            clear()
        else:
            os.system("clear")
        print(content)
        # 休眠 300 毫秒
        time.sleep(0.3)
        content = content[1:] + content[0]


if __name__ == '__main__':
    main()

# 文字对话
# 1、玩家、敌人
# 2、攻击值是随机的
# 3、判断输赢
# 4、玩家可以选择攻击或者防守，防守受到敌人攻击值的 1/10
# 5、显示生命值
# 6、显示玩家 and 敌人名称
# 7、获取输入来进行操作
import random

PLAYER_NAME = "Austin"
ENEMY_NAME = "Jaden"
PLAYER_HP = 100
ENEMY_HP = 80


def attack_value():
    attack_value = random.randint(0, 50)
    return attack_value


def not_dead(hp):
    if hp >= 0:
        return True
    else:
        return False


def being_attack(hp, attack_value):
    hp = hp - attack_value
    return hp


def show_status(name, hp):
    # print(self.hp)
    # print(f"{self.name}' hp is {self.hp}")
    print("{}' hp is {}".format(name, hp))


def win_or_lose(hp):
    if hp > 0:
        print("You Win!")
    else:
        print("You Lose!")


def main():
    global PLAYER_HP, ENEMY_HP
    while not_dead(PLAYER_HP) and not_dead(ENEMY_HP):
        show_status(PLAYER_NAME, PLAYER_HP)
        show_status(ENEMY_NAME, ENEMY_HP)
        user_operation = input("Attack or Defence(A/D):>>>")
        if user_operation.upper() == "A":
            player_attack_value = attack_value()  # 获取攻击值的操作
            enemy_attack_value = attack_value()  # 获取攻击值的操作
            PLAYER_HP = being_attack(PLAYER_HP, enemy_attack_value)
            ENEMY_HP = being_attack(ENEMY_HP, player_attack_value)
        elif user_operation.upper() == "D":
            enemy_attack_value = attack_value() * 0.1  # 获取攻击值的操作
            PLAYER_HP = being_attack(PLAYER_HP, enemy_attack_value)
        else:
            print("请输入 A or D......")
    win_or_lose(PLAYER_HP)


if __name__ == '__main__':
    main()

# 文字对话
# 1、玩家、敌人
# 2、攻击值是随机的
# 3、判断输赢
# 4、玩家可以选择攻击或者防守，防守受到敌人攻击值的 1/10
# 5、显示生命值
# 6、显示玩家 and 敌人名称
# 7、获取输入来进行操作
import random


class Creature():
    def __init__(self, hp, name):
        self.hp = hp
        self.name = name

    def attack(self):
        """
        :return: attack_value
        return-type: random number
        """
        attack_value = random.randint(0, 50)
        # print("attack_value:>>>", attack_value)
        return attack_value

    def not_dead(self):
        # pass
        if self.hp >= 0:
            return True
        else:
            return False

    def being_attack(self, attack_value):
        self.hp = self.hp - attack_value

    def show_status(self):
        # print(self.hp)
        # print(f"{self.name}' hp is {self.hp}")
        print("{}' hp is {}".format(self.name, self.hp))

    def win_or_lose(self):
        if self.not_dead():
            print("You Win!")
        else:
            print("Lose!")


Player = Creature(hp=100, name="Austin")  # 实例化
Enemy = Creature(hp=80, name="Jaden")

while Player.not_dead() and Enemy.not_dead():
    Player.show_status()
    Enemy.show_status()

    user_operation = input("Attack or Defence(A/D):>>>")
    if user_operation.upper() == "A":
        Player_attack_value = Player.attack()  # 获取攻击值的操作
        Enemy_attack_value = Enemy.attack()
        Player.being_attack(Enemy_attack_value)
        Enemy.being_attack(Player_attack_value)
    elif user_operation.upper() == "D":
        Enemy_attack_value = Enemy.attack() * 0.1
        Player.being_attack(Enemy_attack_value)

Player.win_or_lose()

1. 什么是 HTMLHTML 称为超文本标记语言，
是一种标识性的语言。它包括一系列标签。
通过这些标签可以将网络上的文档格式统一，
使分散的 Internet 资源连接为一个逻辑整体。
超
文本是一种组织信息的方式，
它通过超级链接方法将文本中的文字、图表与其他信息媒体相关联。
这些相互关联的信息媒体可能在同一文本中，也可能是其他文件，
或是地理位置相距遥远的某台计算机上的文件。这种组织信息方式将分布在不同位置的信息资源用随机方式进行连接，
为人们查找，检索信息提供方便。#
------
著作权归黄家宝|AI悦创所有
原文链接：https://bornforthis.cn/column/web/book/html-01.html
lst = [1, 2, 3, 4, 5]
userinput = input(":>>>").split(" ")
# a = 1
lst[int(userinput[0]):int(userinput[0])] = [userinput[1]]
print(lst)



Python is an object-oriented programming language
import random
from faker import Faker


# 游戏的完成
# 随机生成敌人名称
# 自定义玩家名称
# 扩展：要求特殊神通：一键回血，副作用：敌人攻击值加倍
class Creature():
    def __init__(self, hp, name=Faker().name()):
        self.hp = hp
        self.name = name
        # self.faker = Faker()
        self.beishu = 1

    def attack(self):
        """
        function: 生成随机攻击值
        :return:
        """
        attack_value = random.randint(0, 50)
        return attack_value

    def not_dead(self):
        if self.hp > 0:
            return True
        else:
            return False

    def being_attack(self, attack_value):
        self.hp = self.hp - attack_value * self.beishu

    def show_status(self):
        # print(self.hp)
        print(f"{self.name}' hp is {self.hp}.")

    def hp_update(self):
        self.hp = 100
        self.beishu = 2


def main():
    player = Creature(100, "Austin")
    enemy = Creature(80)
    while player.not_dead() and enemy.not_dead():
        player.show_status()
        enemy.show_status()
        user_operation = input("Attack or Defence(A or D):>>>").upper()
        if user_operation == "A":
            player_attack_value = player.attack()
            enemy_attack_value = enemy.attack()
            player.being_attack(enemy_attack_value)
            enemy.being_attack(player_attack_value)
        elif user_operation == "D":
            enemy_attack_value = enemy.attack() * 0.1
            player.being_attack(enemy_attack_value)
        elif user_operation == "666":
            s = "请确认您的操作，这将把你的血量恢复至 100\n敌人攻击值将提升两倍。\n取消请输入 No，确认直接 enter or yes:"
            u = input(s)
            if u == "" or u.lower() == "yes":
                player.hp_update()
            else:
                print("您已经取消恢复血量......\n祝您好运！")
                # pass

    if player.not_dead():
        print("You Win.")
    else:
        print("You lose.")


if __name__ == '__main__':
    main()

look


import os

PATH = "."


def postfix(path):
    postfix_lst = ["zip", "rar", "jpg", "parquet", "xlsx", "xls",
                   "png", "ico", "docx"]
    suffix = path.split(".")[-1].lower()
    if suffix not in postfix_lst:
        return path
    else:
        return None


def generate_path(path):
    path_lst = []
    for dirpath, dirnames, filenames in os.walk(path):
        # print(dirpath, dirnames, filenames)
        for filename in filenames:
            path = dirpath + "/" + filename
            # print(path)
            # return path
            path_lst.append(path)
    return path_lst


def open_file(path_lst):
    for path in path_lst:
        print(f"Now Operation file-path:>>>{path}")
        r_path = postfix(path)
        if r_path is not None:
            with open(r_path, "r", encoding="utf-8") as f:
                content = f.read()
                print(content)
                print("-" * 10)
        else:
            pass


def main():
    path_lst = generate_path(PATH)
    # print(path)
    open_file(path_lst)


if __name__ == '__main__':
    main()


aiyc
aiyc2
aiyc
aiyc

from aiyc1v1 import SimpleSearch
ss = SimpleSearch()
ss.main()
1. 什么是 HTMLHTML 称为超文本标记语言，
是一种标识性的语言。它包括一系列标签。
通过这些标签可以将网络上的文档格式统一，
使分散的 Internet 资源连接为一个逻辑整体。
超
文本是一种组织信息的方式，
它通过超级链接方法将文本中的文字、图表与其他信息媒体相关联。
这些相互关联的信息媒体可能在同一文本中，也可能是其他文件，
或是地理位置相距遥远的某台计算机上的文件。这种组织信息方式将分布在不同位置的信息资源用随机方式进行连接，
为人们查找，检索信息提供方便。#
------
著作权归黄家宝|AI悦创所有
原文链接：https://bornforthis.cn/column/web/book/html-01.html



Read Martin Luther King Jr.'s 'I Have a Dream' speech in its entirety
Updated January 14, 20221:53 PM ET
Heard on Talk of the Nation
17-Minute Listen
Download
Transcript

Civil rights leader Martin Luther King Jr. addresses the crowd at the Lincoln Memorial in Washington, D.C., where he gave his "I Have a Dream" speech on Aug. 28, 1963, as part of the March on Washington.
AFP via Getty Images
Monday marks the birthday of Martin Luther King Jr. Below is a transcript of his celebrated "I Have a Dream" speech, delivered on Aug. 28, 1963, on the steps of the Lincoln Memorial. NPR's Talk of the Nation aired the speech in 2010 — listen to that broadcast at the audio link above.


Martin Luther King Jr. and other civil rights leaders gather before a rally at the Lincoln Memorial on Aug. 28, 1963, in Washington.
National Archives/Hulton Archive via Getty Images
Rev. Martin Luther King Jr.: Five score years ago, a great American, in whose symbolic shadow we stand today, signed the Emancipation Proclamation. This momentous decree came as a great beacon light of hope to millions of Negro slaves who had been seared in the flames of withering injustice. It came as a joyous daybreak to end the long night of their captivity.

But 100 years later, the Negro still is not free. One hundred years later, the life of the Negro is still sadly crippled by the manacles of segregation and the chains of discrimination. One hundred years later, the Negro lives on a lonely island of poverty in the midst of a vast ocean of material prosperity. One hundred years later the Negro is still languished in the corners of American society and finds himself in exile in his own land. And so we've come here today to dramatize a shameful condition. In a sense we've come to our nation's capital to cash a check.

The Power Of Martin Luther King Jr.'s Anger
CODE SWITCH
The Power Of Martin Luther King Jr.'s Anger
When the architects of our republic wrote the magnificent words of the Constitution and the Declaration of Independence, they were signing a promissory note to which every American was to fall heir. This note was a promise that all men — yes, Black men as well as white men — would be guaranteed the unalienable rights of life, liberty and the pursuit of happiness.

It is obvious today that America has defaulted on this promissory note insofar as her citizens of color are concerned. Instead of honoring this sacred obligation, America has given the Negro people a bad check, a check which has come back marked insufficient funds.

But we refuse to believe that the bank of justice is bankrupt.

We refuse to believe that there are insufficient funds in the great vaults of opportunity of this nation. And so we've come to cash this check, a check that will give us upon demand the riches of freedom and the security of justice.

We have also come to his hallowed spot to remind America of the fierce urgency of now. This is no time to engage in the luxury of cooling off or to take the tranquilizing drug of gradualism.


Civil rights protesters march from the Washington Monument to the Lincoln Memorial for the March on Washington on Aug. 28, 1963.
Kurt Severin/Three Lions/Hulton Archive/Getty Images
Now is the time to make real the promises of democracy. Now is the time to rise from the dark and desolate valley of segregation to the sunlit path of racial justice. Now is the time to lift our nation from the quick sands of racial injustice to the solid rock of brotherhood. Now is the time to make justice a reality for all of God's children.

It would be fatal for the nation to overlook the urgency of the moment. This sweltering summer of the Negro's legitimate discontent will not pass until there is an invigorating autumn of freedom and equality. 1963 is not an end, but a beginning. Those who hope that the Negro needed to blow off steam and will now be content will have a rude awakening if the nation returns to business as usual.

There will be neither rest nor tranquility in America until the Negro is granted his citizenship rights. The whirlwinds of revolt will continue to shake the foundations of our nation until the bright day of justice emerges.

But there is something that I must say to my people who stand on the warm threshold which leads into the palace of justice. In the process of gaining our rightful place, we must not be guilty of wrongful deeds. Let us not seek to satisfy our thirst for freedom by drinking from the cup of bitterness and hatred.

Bayard Rustin: The Man Behind the March on Washington (2021)
THROUGHLINE
Bayard Rustin: The Man Behind the March on Washington (2021)
We must forever conduct our struggle on the high plane of dignity and discipline. We must not allow our creative protest to degenerate into physical violence. Again and again, we must rise to the majestic heights of meeting physical force with soul force. The marvelous new militancy which has engulfed the Negro community must not lead us to a distrust of all white people, for many of our white brothers, as evidenced by their presence here today, have come to realize that their destiny is tied up with our destiny.

And they have come to realize that their freedom is inextricably bound to our freedom. We cannot walk alone. And as we walk, we must make the pledge that we shall always march ahead. We cannot turn back.

There are those who are asking the devotees of civil rights, when will you be satisfied? We can never be satisfied as long as the Negro is the victim of the unspeakable horrors of police brutality. We can never be satisfied as long as our bodies, heavy with the fatigue of travel, cannot gain lodging in the motels of the highways and the hotels of the cities.

We cannot be satisfied as long as the Negro's basic mobility is from a smaller ghetto to a larger one. We can never be satisfied as long as our children are stripped of their selfhood and robbed of their dignity by signs stating: for whites only.

We cannot be satisfied as long as a Negro in Mississippi cannot vote and a Negro in New York believes he has nothing for which to vote.

No, no, we are not satisfied, and we will not be satisfied until justice rolls down like waters, and righteousness like a mighty stream.

How The Voting Rights Act Came To Be And How It's Changed
POLITICS
How The Voting Rights Act Came To Be And How It's Changed
I am not unmindful that some of you have come here out of great trials and tribulations. Some of you have come fresh from narrow jail cells. Some of you have come from areas where your quest for freedom left you battered by the storms of persecution and staggered by the winds of police brutality. You have been the veterans of creative suffering. Continue to work with the faith that unearned suffering is redemptive. Go back to Mississippi, go back to Alabama, go back to South Carolina, go back to Georgia, go back to Louisiana, go back to the slums and ghettos of our Northern cities, knowing that somehow this situation can and will be changed.

Let us not wallow in the valley of despair, I say to you today, my friends.

So even though we face the difficulties of today and tomorrow, I still have a dream. It is a dream deeply rooted in the American dream. I have a dream that one day this nation will rise up and live out the true meaning of its creed: We hold these truths to be self-evident, that all men are created equal.


People clap and sing along to a freedom song between speeches at the March on Washington for Jobs and Freedom in 1963.
Express Newspapers via Getty Images
I have a dream that one day on the red hills of Georgia, the sons of former slaves and the sons of former slave owners will be able to sit down together at the table of brotherhood.

I have a dream that one day even the state of Mississippi, a state sweltering with the heat of injustice, sweltering with the heat of oppression will be transformed into an oasis of freedom and justice.

I have a dream that my four little children will one day live in a nation where they will not be judged by the color of their skin but by the content of their character. I have a dream today.

I have a dream that one day down in Alabama with its vicious racists, with its governor having his lips dripping with the words of interposition and nullification, one day right down in Alabama little Black boys and Black girls will be able to join hands with little white boys and white girls as sisters and brothers. I have a dream today.

I have a dream that one day every valley shall be exalted, every hill and mountain shall be made low, the rough places will be made plain, and the crooked places will be made straight, and the glory of the Lord shall be revealed, and all flesh shall see it together.

CODE SWITCH
Nikole Hannah-Jones on the power of collective memory
This is our hope. This is the faith that I go back to the South with. With this faith, we will be able to hew out of the mountain of despair a stone of hope. With this faith we will be able to transform the jangling discords of our nation into a beautiful symphony of brotherhood. With this faith we will be able to work together, to pray together, to struggle together, to go to jail together, to stand up for freedom together, knowing that we will be free one day.

This will be the day when all of God's children will be able to sing with new meaning: My country, 'tis of thee, sweet land of liberty, of thee I sing. Land where my fathers died, land of the pilgrims' pride, from every mountainside, let freedom ring.

And if America is to be a great nation, this must become true. And so let freedom ring from the prodigious hilltops of New Hampshire. Let freedom ring from the mighty mountains of New York. Let freedom ring from the heightening Alleghenies of Pennsylvania. Let freedom ring from the snowcapped Rockies of Colorado. Let freedom ring from the curvaceous slopes of California. But not only that, let freedom ring from Stone Mountain of Georgia. Let freedom ring from Lookout Mountain of Tennessee. Let freedom ring from every hill and molehill of Mississippi. From every mountainside, let freedom ring.

And when this happens, and when we allow freedom ring, when we let it ring from every village and every hamlet, from every state and every city, we will be able to speed up that day when all of God's children, Black men and white men, Jews and Gentiles, Protestants and Catholics, will be able to join hands and sing in the words of the old Negro spiritual: Free at last. Free at last. Thank God almighty, we are free at last.
from aiyc1v1 import DataManager, SimpleSearch
path = "/Users/huangjiabao/GitHub/MacBookPro16-Code/PythonCoder/StudentCoder/01_WillQX/Project/00/Prototypes-MP-GUI_Prototype/flask-server/python-src/Analysis.py"
data = DataManager(path).postfix()
from aiyc1v1 import Simple_NlP
# Sid = Simple_NlP(path="I_have_a_Dream.txt", filename="demo.html").main()

# num = 1.0
# print(type(num))
# print(num)


# str 字符串
str_content = "Hello AndersonHJB"
print(type(str_content))
# 见名知意
print(str_content)
# 1、有序性
# l    o    v    e  y    o    u
# 0    1    2    3456    7    8「从左到右」
# -9   -8   -7 -6-5-4-3  -2   -1  「从右到左」
# 下标
# 2、不可变性
# 3、任意数据类型/只要你键盘能输入的，都可以放入字符串中

# list 列表
lst = [1, "Austin", 2.0, "Jaden", (1, 2, 3, 4)]
# 1、有序性
# [1, "Austin", 2.0, "Jaden"]
#  0      1      2      3「从左到右」
# -4     -3     -2     -1 「从右到左」
# 2、可变性
# 列表被创建出来之后，可以被修改、删除、添加等操作
# 3、任意数据类型
# Python 的所有数据类型，均可放入。原本是什么类型，放进去后，还是什么类型——类似与于：书架
# n = 1

# 元组 tuple
t = (1, "Austin", 1.0, "book", [1, 2, 3, 4])
print(t)
print(type(t))
# 1、有序性
# 2、不可变
# 3、任意数据类型

# 字典 dict
d = {"name": "Austin", "age": 19, "key": "value"}
print(type(d))
print(d)
# 1、key: value
# 2、 key-> 钥匙🔑，能变形吗？-> 不能变形「不可变」：key 是要求不可变的数据类型
# 3、value 任意数据类型
# 4、无序的、python3.6+ 之后 字典是有序的，但是平时所说的有序，你目前用不到
# 1、列表、元组可以做key 吗？
# 2、真的 value 是任意数据类型吗？
d = {(1, 2, 3, 4): "list", "name": "AndersonHJB", 1: 12, "name1": [1, 2, 3]}
print(d)

# set 集合
s = {1, 2, 2, 2, 2, 2, 4, 6, (1, 2)}
print(s)
# 1、确定性
# 2、互异性
# 3、无序性
# PS：列表可变，可变造就了未知性与可变性
lst = [1, 2, 3, 3, 3, 4, 5, 6, 7]
s = set(lst)
print(s)

t = tuple(lst)
print(t)

string = str(lst)
print(string)

# d = dict(lst)
lst = [("name", "Austin"), ("age", 19)]
d = dict(lst)
print(d)

# 布尔型 bool
bool_true = True
bool_false = False
print(bool_false)
print(bool_true)

a = 91























print(a // 10 + a % 10)
print(a % 10 * 10 + a // 10)

# a = 1
# print(a + 10)
# print(a)
# a = a + 10
# print(a)
a = 1
a = a + 10
print(a)

b = 1
b += 10  # b = b + 10
print(b)

a = 1
b = 1
r = a + b
print(r)

a = 1.0
b = 1
r = a + b
print(r)

a = 2.0
b = 1
r = a - b
print(r)

a = 2
b = 1
r = a - b
print(r)

a = 2
b = 1
r = a * b
print(r)

a = 2
b = 1
r = a / b
print(r)
# print(a / b)
# print((1 + 1.0))

# a = 25
# Q1: 个位和十位相加 -> 2 + 5 = 7
# Q2: 25 52、41 14
# Q3: 在三位数的情况下，如何处理

a = 25
gewei = a % 10
shiwei = a // 10
r = gewei + shiwei
print(r)
print(gewei, shiwei, sep="", end="")  # 形，用不到这个 value，同时输出
# 你要用到 52，用的了
revers = gewei * 10 + shiwei
print(revers)
r = revers + 1
print(r)











boolean_1 = 1
boolean_2 = 2
r = boolean_2 > boolean_1
print(r)

print(boolean_2 < boolean_1)
print(1 < 2)
print(1 == 1)

import re

html = '''<div id="songs-list">
    <h2 class="title">经典老歌</h2>
    <p class="introduction">
        经典老歌列表
    </p>
    <ul id="list" class="list-group">
        <li data-view="2">一路上有你</li>
        <li data-view="7">
            <a href="/2.mp3" singer="任贤齐">沧海一声笑</a>
        </li>
        <li data-view="4" class="active">
            <a href="/3.mp3" singer="齐秦">往事随风</a>
        </li>
        <li data-view="6"><a href="/4.mp3" singer="beyond">光辉岁月</a></li>
        <li data-view="5"><a href="/5.mp3" singer="陈慧琳">记事本</a></li>
        <li data-view="5">
            <a href="/6.mp3" singer="邓丽君"><i class="fa fa-user"></i>但愿人长久</a>
        </li>
    </ul>
</div>'''
# pattern = '<li.*?active.*?singer="(\w+)">(\w+)</a>'
pattern = '<a.*?>(?:<i.*?</i>)*(.*?)</a>'
result = re.findall(pattern, html, re.S)
# result = re.search('<li.*?active.*?singer="(.*?)">(.*?)</a>', html, re.S)
# print(result.groups())
if result:
    for i in result:
        print(i)
#     # print(result.group(1, 2))

import requests
import re
from requests.exceptions import RequestException
from urllib.parse import urljoin

BASE = "https://bornforthis.cn/web_runing/crawler/regex/"


def requests_fun(url, binary=False):
    try:
        response = requests.get(url)
        if response.status_code == 200:
            if binary:
                return response.content
            else:
                return response.text
        return None
    except RequestException as e:
        return None


def save_music(path, binary):
    with open(path, "wb") as f:
        f.write(binary)


def parse(html):
    pattern = '<a.*?href="(.*?)".*?</a>'
    result = re.findall(pattern, html)
    return result


def joint(url_lst):
    url_list = []
    for url in url_lst:
        url = urljoin(BASE, url)
        url_list.append(url)
    return url_list


def postfix(url):
    music_name = url.split("/")[-1]
    return music_name


def main():
    url = "https://bornforthis.cn/web_runing/crawler/regex/index.html"
    html = requests_fun(url)
    # url_lst = parse(html)
    url_list = joint(parse(html))
    # print(url_list)
    for url in url_list:
        # print(url)
        binary_content = requests_fun(url, binary=True)
        # print(binary_content)
        save_music(f"data/music/{postfix(url)}", binary_content)


if __name__ == '__main__':
    main()






import random

player01_name = input("请输入玩家1号的名称")
player02_name = input("请输入玩家2号的名称")


# ----------------玩家初始信息------------------
class player():
    def __init__(self):
        self.health_point = 500

    def Attack_judge(self, name):
        input_text = True
        while input_text:
            attack_pattern = input(f"{name}请输入想要攻击的方式，输入“攻击”或者“防守”")
            if attack_pattern == "攻击" or "防守":
                input_text = False
            else:
                print("输入有误，请重新输入")
        return attack_pattern


player01 = player()
player02 = player()

# ---------------初始化---------------------
print("游戏即将开始。")
print(f"第一回合内{player01_name}，{player01_name}可以选择攻击或者防御，当选择防御时，{player01_name}在下一回合受到的攻击为实际伤害的十分之一")
print(f"首先请{player01_name}开始攻击")
i = True
while i:
    if player01.health_point <= 0 or player02.health_point <= 0:
        i = False
    else:
        attack_pattern_01 = player01.Attack_judge(player01_name)
        attack_pattern_02 = player02.Attack_judge(player02_name)
        # ---------------判断----------------
        # ---------------玩家1防御玩家2攻击-----------------
        if attack_pattern_01 == "防御" and attack_pattern_02 == "攻击":
            damage_02 = random.randint(50, 100)
            player01_name.health_point -= damage_02 // 10
            print(f"当前{player01_name}的血量为{player01.health_point}\n{player02_name}的血量为{player02.health_point}")
        # ---------------玩家1攻击玩家2防守-----------------
        elif attack_pattern_02 == "防御" and attack_pattern_01 == "攻击":
            damage_01 = random.randint(50, 100)
            player02.health_point -= damage_01 // 10
            print(f"当前{player01_name}的血量为{player01.health_point}\n{player02_name}的血量为{player02.health_point}")
        # ---------------玩家1攻击玩家2攻击-----------------
        elif attack_pattern_01 == "攻击" and attack_pattern_02 == "攻击":
            damage_01 = random.randint(50, 100)
            damage_02 = random.randint(50, 100)
            player01.health_point -= damage_02
            player02.health_point -= damage_01
            print(f"当前{player01_name}的血量为{player01.health_point}\n{player02_name}的血量为{player02.health_point}")
        # --------------玩家1防御玩家2防御------------------
        else:
            print("此轮攻击未造成双方血量减少")
# ---------------结果--------------
if player01.health_point <= 0 or player02.health_point >= 0:
    print(f"{player02_name}获胜。")
elif player01.health_point >= 0 or player02.health_point <= 0:
    print(f"{player01_name}获胜。")
else:
    print("双方平局")

import random

player01_name = input("请输入玩家1号的名称")
player02_name = input("请输入玩家2号的名称")


# ----------------玩家初始信息------------------
class player():
    def __init__(self):
        self.health_point = 100

    def Attack_or_Defence(self, name):
        input_text = True
        while input_text:
            attack_pattern = input(f"{name}请输入想要A的方式，输入“A”或者“D”")
            if attack_pattern == "A" or "D":
                input_text = False
            else:
                print("输入有误，请重新输入")
        return attack_pattern


# def Attack_or_Defence(name):
#     input_text = True
#     while input_text:
#         attack_pattern = input(f"{name}请输入想要A的方式，输入“A”或者“D”")
#         if attack_pattern == "A" or "D":
#             input_text = False
#         else:
#             print("输入有误，请重新输入")
#     return attack_pattern


player01 = player()
player02 = player()

# ---------------初始化---------------------
print("游戏即将开始。")
print(
    f"第一回合内{player01_name}，{player01_name}可以选择A或者防御，当选择防御时，{player01_name}在下一回合受到的A为实际伤害的十分之一")
print(f"首先请{player01_name}开始A")
i = True
while i:
    if player01.health_point <= 0 or player02.health_point <= 0:
        i = False
    damage = random.randint(50, 100)
    # attack_pattern_01 = Attack_or_Defence(player01_name)
    # attack_pattern_02 = Attack_or_Defence(player02_name)
    attack_pattern_01 = player01.Attack_or_Defence(name=player01_name)
    attack_pattern_02 = player01.Attack_or_Defence(name=player02_name)
    # input_text = True
    # while input_text:
    #     attack_pattern_01 = input(f"{player01_name}请输入想要A的方式，输入“A”或者“D”")
    #     if attack_pattern_01 == "A" or "D":
    #         input_text = False
    #     else:
    #         print("输入有误，请重新输入")
    # input_text = True
    # while input_text:
    #     attack_pattern_02 = input(f"{player02_name}请输入想要A的方式，输入“A”或者“D”")
    #     if attack_pattern_02 == "A" or "D":
    #         input_text = False
    #     else:
    #         print("输入有误，请重新输入")
    # ---------------判断----------------
    # ---------------玩家1防御玩家2A-----------------
    if attack_pattern_01 == "D" and attack_pattern_02 == "A":
        damage_02 = random.randint(50, 100)
        player01_name.health_point -= damage_02 // 10
        print(f"当前{player01_name}的血量为{player01.health_point}\n{player02_name}的血量为{player02.health_point}")
    # ---------------玩家1A玩家2D-----------------
    elif attack_pattern_02 == "防御" and attack_pattern_01 == "A":
        damage_01 = random.randint(50, 100)
        player02.health_point -= damage_01 // 10
        print(f"当前{player01_name}的血量为{player01.health_point}\n{player02_name}的血量为{player02.health_point}")
    # ---------------玩家1A玩家2A-----------------
    elif attack_pattern_01 == "A" and attack_pattern_02 == "A":
        damage_01 = random.randint(50, 100)
        damage_02 = random.randint(50, 100)
        player01.health_point -= damage_02
        player02.health_point -= damage_01
        print(f"当前{player01_name}的血量为{player01.health_point}\n{player02_name}的血量为{player02.health_point}")
    # --------------玩家1防御玩家2防御------------------
    else:
        print("此轮A未造成双方血量减少")
# ---------------结果--------------
if player01.health_point <= 0 or player02.health_point >= 0:
    print(f"{player02_name}获胜。")
elif player01.health_point >= 0 or player02.health_point <= 0:
    print(f"{player01_name}获胜。")
else:
    print("双方平局")


class Animals():
    def __init__(self):
        self.x = 0
dog = Animals()
print(dog.x)
import random

player01 = input("请输入玩家1号的名称")
player02 = input("请输入玩家2号的名称")


# ----------------玩家初始信息------------------
class player():
    def __init__(self):
        self.health_point = 500


player01 = player()
player02 = player()

# ---------------初始化---------------------
print("游戏即将开始。")
print(f"第一回合内{player01}，{player01}可以选择攻击或者防御，当选择防御时，{player01}在下一回合受到的攻击为实际伤害的十分之一")
print(f"首先请{player01}开始攻击")
i = True
while i:
    if player01.health_point <= 0 or player02.health_point <= 0:
        i = False
    damage = random.randint(50, 100)
    input_text = True
    while input_text:
        attack_pattern_01 = input(f"{player01}请输入想要攻击的方式，输入“攻击”或者“防守”")
        if attack_pattern_01 == "攻击" or "防守":
            input_text = False
        else:
            print("输入有误，请重新输入")
    input_text = True
    while input_text:
        attack_pattern_02 = input(f"{player02}请输入想要攻击的方式，输入“攻击”或者“防守”")
        if attack_pattern_02 == "攻击" or "防守":
            input_text = False
        else:
            print("输入有误，请重新输入")
    # ---------------判断----------------
    # ---------------玩家1防御玩家2攻击-----------------
    if attack_pattern_01 == "防御" and attack_pattern_02 == "攻击":
        damage_02 = random.randint(50, 100)
        player01.health_point -= damage_02 // 10
        print(f"当前{player01}的血量为"
              f"{player01.health_point}\n{player02}"
              f"的血量为{player02.health_point}")
    # ---------------玩家1攻击玩家2防守-----------------
    elif attack_pattern_02 == "防御" and attack_pattern_01 == "攻击":
        damage_01 = random.randint(50, 100)
        player02.health_point -= damage_01 // 10
        print(f"当前{player01}的血量为{player01.health_point}\n{player02}的血量为{player02.health_point}")
    # ---------------玩家1攻击玩家2攻击-----------------
    elif attack_pattern_01 == "攻击" and attack_pattern_02 == "攻击":
        damage_01 = random.randint(50, 100)
        damage_02 = random.randint(50, 100)
        player01.health_point -= damage_02
        player02.health_point -= damage_01
        print(f"当前{player01}的血量为{player01.health_point}\n{player02}的血量为{player02.health_point}")
    # --------------玩家1防御玩家2防御------------------
    else:
        print("此轮攻击未造成双方血量减少")

# author: look
import random

player01_name = input("请输入玩家1号的名称")
player02_name = input("请输入玩家2号的名称")


# ----------------玩家初始信息------------------
class player():
    def __init__(self):
        self.health_point = 500


player01 = player()  # 实例化
player02 = player()

# ---------------初始化---------------------
print("游戏即将开始。")
print(f"第一回合内{player01}，{player01}可以选择攻击或者防御，当选择防御时，{player01}在下一回合受到的攻击为实际伤害的十分之一")
print(f"首先请{player01}开始攻击")
i = True
while i:
    if player01.health_point <= 0 or player02.health_point <= 0:
        i = False
    damage = random.randint(50, 100)
    input_text = True
    while input_text:
        attack_pattern_01 = input(f"{player01}请输入想要攻击的方式，输入“攻击”或者“防守”")
        if attack_pattern_01 == "攻击" or "防守":
            input_text = False
        else:
            print("输入有误，请重新输入")
    input_text = True
    while input_text:
        attack_pattern_02 = input(f"{player02}请输入想要攻击的方式，输入“攻击”或者“防守”")
        if attack_pattern_02 == "攻击" or "防守":
            input_text = False
        else:
            print("输入有误，请重新输入")
    # ---------------判断----------------
    # ---------------玩家1防御玩家2攻击-----------------
    if attack_pattern_01 == "防御" and attack_pattern_02 == "攻击":
        damage_02 = random.randint(50, 100)
        player01.health_point -= damage_02 // 10
        print(f"当前{player01}的血量为{player01.health_point}\n{player02}的血量为{player02.health_point}")
    # ---------------玩家1攻击玩家2防守-----------------
    elif attack_pattern_02 == "防御" and attack_pattern_01 == "攻击":
        damage_01 = random.randint(50, 100)
        player02.health_point -= damage_01 // 10
        print(f"当前{player01}的血量为{player01.health_point}\n{player02}的血量为{player02.health_point}")
    # ---------------玩家1攻击玩家2攻击-----------------
    elif attack_pattern_01 == "攻击" and attack_pattern_02 == "攻击":
        damage_01 = random.randint(50, 100)
        damage_02 = random.randint(50, 100)
        player01.health_point -= damage_02
        player02.health_point -= damage_01
        print(f"当前{player01}的血量为{player01.health_point}\n{player02}的血量为{player02.health_point}")
    # --------------玩家1防御玩家2防御------------------
    else:
        print("此轮攻击未造成双方血量减少")
# ---------------结果--------------
if player01.health_point <= 0 or player02.health_point >= 0:
    print(f"{player02}获胜。")
elif player01.health_point >= 0 or player02.health_point <= 0:
    print(f"{player01}获胜。")
else:
    print("双方平局")


import platform
import os
import sys
import time


def main():
    content = "你好，我是悦创。。。"
    while True:
        # 清理屏幕输出
        if platform.system().lower() == "windows":
            os.system("cls")
        elif 'ipykernel' in sys.modules:
            from IPython.display import clear_output as clear
            clear()
        else:
            os.system("clear")
        print(content)
        # 休眠 300 毫秒
        time.sleep(0.3)
        content = content[1:] + content[0]


if __name__ == '__main__':
    main()

# 文字对话
# 1、玩家、敌人
# 2、攻击值是随机的
# 3、判断输赢
# 4、玩家可以选择攻击或者防守，防守受到敌人攻击值的 1/10
# 5、显示生命值
# 6、显示玩家 and 敌人名称
# 7、获取输入来进行操作
import random

PLAYER_NAME = "Austin"
ENEMY_NAME = "Jaden"
PLAYER_HP = 100
ENEMY_HP = 80


def attack_value():
    attack_value = random.randint(0, 50)
    return attack_value


def not_dead(hp):
    if hp >= 0:
        return True
    else:
        return False


def being_attack(hp, attack_value):
    hp = hp - attack_value
    return hp


def show_status(name, hp):
    # print(self.hp)
    # print(f"{self.name}' hp is {self.hp}")
    print("{}' hp is {}".format(name, hp))


def win_or_lose(hp):
    if hp > 0:
        print("You Win!")
    else:
        print("You Lose!")


def main():
    global PLAYER_HP, ENEMY_HP
    while not_dead(PLAYER_HP) and not_dead(ENEMY_HP):
        show_status(PLAYER_NAME, PLAYER_HP)
        show_status(ENEMY_NAME, ENEMY_HP)
        user_operation = input("Attack or Defence(A/D):>>>")
        if user_operation.upper() == "A":
            player_attack_value = attack_value()  # 获取攻击值的操作
            enemy_attack_value = attack_value()  # 获取攻击值的操作
            PLAYER_HP = being_attack(PLAYER_HP, enemy_attack_value)
            ENEMY_HP = being_attack(ENEMY_HP, player_attack_value)
        elif user_operation.upper() == "D":
            enemy_attack_value = attack_value() * 0.1  # 获取攻击值的操作
            PLAYER_HP = being_attack(PLAYER_HP, enemy_attack_value)
        else:
            print("请输入 A or D......")
    win_or_lose(PLAYER_HP)


if __name__ == '__main__':
    main()

# 文字对话
# 1、玩家、敌人
# 2、攻击值是随机的
# 3、判断输赢
# 4、玩家可以选择攻击或者防守，防守受到敌人攻击值的 1/10
# 5、显示生命值
# 6、显示玩家 and 敌人名称
# 7、获取输入来进行操作
import random


class Creature():
    def __init__(self, hp, name):
        self.hp = hp
        self.name = name

    def attack(self):
        """
        :return: attack_value
        return-type: random number
        """
        attack_value = random.randint(0, 50)
        # print("attack_value:>>>", attack_value)
        return attack_value

    def not_dead(self):
        # pass
        if self.hp >= 0:
            return True
        else:
            return False

    def being_attack(self, attack_value):
        self.hp = self.hp - attack_value

    def show_status(self):
        # print(self.hp)
        # print(f"{self.name}' hp is {self.hp}")
        print("{}' hp is {}".format(self.name, self.hp))

    def win_or_lose(self):
        if self.not_dead():
            print("You Win!")
        else:
            print("Lose!")


Player = Creature(hp=100, name="Austin")  # 实例化
Enemy = Creature(hp=80, name="Jaden")

while Player.not_dead() and Enemy.not_dead():
    Player.show_status()
    Enemy.show_status()

    user_operation = input("Attack or Defence(A/D):>>>")
    if user_operation.upper() == "A":
        Player_attack_value = Player.attack()  # 获取攻击值的操作
        Enemy_attack_value = Enemy.attack()
        Player.being_attack(Enemy_attack_value)
        Enemy.being_attack(Player_attack_value)
    elif user_operation.upper() == "D":
        Enemy_attack_value = Enemy.attack() * 0.1
        Player.being_attack(Enemy_attack_value)

Player.win_or_lose()

1. 什么是 HTMLHTML 称为超文本标记语言，
是一种标识性的语言。它包括一系列标签。
通过这些标签可以将网络上的文档格式统一，
使分散的 Internet 资源连接为一个逻辑整体。
超
文本是一种组织信息的方式，
它通过超级链接方法将文本中的文字、图表与其他信息媒体相关联。
这些相互关联的信息媒体可能在同一文本中，也可能是其他文件，
或是地理位置相距遥远的某台计算机上的文件。这种组织信息方式将分布在不同位置的信息资源用随机方式进行连接，
为人们查找，检索信息提供方便。#
------
著作权归黄家宝|AI悦创所有
原文链接：https://bornforthis.cn/column/web/book/html-01.html
lst = [1, 2, 3, 4, 5]
userinput = input(":>>>").split(" ")
# a = 1
lst[int(userinput[0]):int(userinput[0])] = [userinput[1]]
print(lst)



Python is an object-oriented programming language
import random
from faker import Faker


# 游戏的完成
# 随机生成敌人名称
# 自定义玩家名称
# 扩展：要求特殊神通：一键回血，副作用：敌人攻击值加倍
class Creature():
    def __init__(self, hp, name=Faker().name()):
        self.hp = hp
        self.name = name
        # self.faker = Faker()
        self.beishu = 1

    def attack(self):
        """
        function: 生成随机攻击值
        :return:
        """
        attack_value = random.randint(0, 50)
        return attack_value

    def not_dead(self):
        if self.hp > 0:
            return True
        else:
            return False

    def being_attack(self, attack_value):
        self.hp = self.hp - attack_value * self.beishu

    def show_status(self):
        # print(self.hp)
        print(f"{self.name}' hp is {self.hp}.")

    def hp_update(self):
        self.hp = 100
        self.beishu = 2


def main():
    player = Creature(100, "Austin")
    enemy = Creature(80)
    while player.not_dead() and enemy.not_dead():
        player.show_status()
        enemy.show_status()
        user_operation = input("Attack or Defence(A or D):>>>").upper()
        if user_operation == "A":
            player_attack_value = player.attack()
            enemy_attack_value = enemy.attack()
            player.being_attack(enemy_attack_value)
            enemy.being_attack(player_attack_value)
        elif user_operation == "D":
            enemy_attack_value = enemy.attack() * 0.1
            player.being_attack(enemy_attack_value)
        elif user_operation == "666":
            s = "请确认您的操作，这将把你的血量恢复至 100\n敌人攻击值将提升两倍。\n取消请输入 No，确认直接 enter or yes:"
            u = input(s)
            if u == "" or u.lower() == "yes":
                player.hp_update()
            else:
                print("您已经取消恢复血量......\n祝您好运！")
                # pass

    if player.not_dead():
        print("You Win.")
    else:
        print("You lose.")


if __name__ == '__main__':
    main()

look


import os

PATH = "."


def postfix(path):
    postfix_lst = ["zip", "rar", "jpg", "parquet", "xlsx", "xls",
                   "png", "ico", "docx"]
    suffix = path.split(".")[-1].lower()
    if suffix not in postfix_lst:
        return path
    else:
        return None


def generate_path(path):
    path_lst = []
    for dirpath, dirnames, filenames in os.walk(path):
        # print(dirpath, dirnames, filenames)
        for filename in filenames:
            path = dirpath + "/" + filename
            # print(path)
            # return path
            path_lst.append(path)
    return path_lst


def open_file(path_lst):
    for path in path_lst:
        print(f"Now Operation file-path:>>>{path}")
        r_path = postfix(path)
        if r_path is not None:
            with open(r_path, "r", encoding="utf-8") as f:
                content = f.read()
                print(content)
                print("-" * 10)
        else:
            pass


def main():
    path_lst = generate_path(PATH)
    # print(path)
    open_file(path_lst)


if __name__ == '__main__':
    main()


aiyc
aiyc2
aiyc
aiyc

from aiyc1v1 import SimpleSearch
ss = SimpleSearch()
ss.main()
1. 什么是 HTMLHTML 称为超文本标记语言，
是一种标识性的语言。它包括一系列标签。
通过这些标签可以将网络上的文档格式统一，
使分散的 Internet 资源连接为一个逻辑整体。
超
文本是一种组织信息的方式，
它通过超级链接方法将文本中的文字、图表与其他信息媒体相关联。
这些相互关联的信息媒体可能在同一文本中，也可能是其他文件，
或是地理位置相距遥远的某台计算机上的文件。这种组织信息方式将分布在不同位置的信息资源用随机方式进行连接，
为人们查找，检索信息提供方便。#
------
著作权归黄家宝|AI悦创所有
原文链接：https://bornforthis.cn/column/web/book/html-01.html



Read Martin Luther King Jr.'s 'I Have a Dream' speech in its entirety
Updated January 14, 20221:53 PM ET
Heard on Talk of the Nation
17-Minute Listen
Download
Transcript

Civil rights leader Martin Luther King Jr. addresses the crowd at the Lincoln Memorial in Washington, D.C., where he gave his "I Have a Dream" speech on Aug. 28, 1963, as part of the March on Washington.
AFP via Getty Images
Monday marks the birthday of Martin Luther King Jr. Below is a transcript of his celebrated "I Have a Dream" speech, delivered on Aug. 28, 1963, on the steps of the Lincoln Memorial. NPR's Talk of the Nation aired the speech in 2010 — listen to that broadcast at the audio link above.


Martin Luther King Jr. and other civil rights leaders gather before a rally at the Lincoln Memorial on Aug. 28, 1963, in Washington.
National Archives/Hulton Archive via Getty Images
Rev. Martin Luther King Jr.: Five score years ago, a great American, in whose symbolic shadow we stand today, signed the Emancipation Proclamation. This momentous decree came as a great beacon light of hope to millions of Negro slaves who had been seared in the flames of withering injustice. It came as a joyous daybreak to end the long night of their captivity.

But 100 years later, the Negro still is not free. One hundred years later, the life of the Negro is still sadly crippled by the manacles of segregation and the chains of discrimination. One hundred years later, the Negro lives on a lonely island of poverty in the midst of a vast ocean of material prosperity. One hundred years later the Negro is still languished in the corners of American society and finds himself in exile in his own land. And so we've come here today to dramatize a shameful condition. In a sense we've come to our nation's capital to cash a check.

The Power Of Martin Luther King Jr.'s Anger
CODE SWITCH
The Power Of Martin Luther King Jr.'s Anger
When the architects of our republic wrote the magnificent words of the Constitution and the Declaration of Independence, they were signing a promissory note to which every American was to fall heir. This note was a promise that all men — yes, Black men as well as white men — would be guaranteed the unalienable rights of life, liberty and the pursuit of happiness.

It is obvious today that America has defaulted on this promissory note insofar as her citizens of color are concerned. Instead of honoring this sacred obligation, America has given the Negro people a bad check, a check which has come back marked insufficient funds.

But we refuse to believe that the bank of justice is bankrupt.

We refuse to believe that there are insufficient funds in the great vaults of opportunity of this nation. And so we've come to cash this check, a check that will give us upon demand the riches of freedom and the security of justice.

We have also come to his hallowed spot to remind America of the fierce urgency of now. This is no time to engage in the luxury of cooling off or to take the tranquilizing drug of gradualism.


Civil rights protesters march from the Washington Monument to the Lincoln Memorial for the March on Washington on Aug. 28, 1963.
Kurt Severin/Three Lions/Hulton Archive/Getty Images
Now is the time to make real the promises of democracy. Now is the time to rise from the dark and desolate valley of segregation to the sunlit path of racial justice. Now is the time to lift our nation from the quick sands of racial injustice to the solid rock of brotherhood. Now is the time to make justice a reality for all of God's children.

It would be fatal for the nation to overlook the urgency of the moment. This sweltering summer of the Negro's legitimate discontent will not pass until there is an invigorating autumn of freedom and equality. 1963 is not an end, but a beginning. Those who hope that the Negro needed to blow off steam and will now be content will have a rude awakening if the nation returns to business as usual.

There will be neither rest nor tranquility in America until the Negro is granted his citizenship rights. The whirlwinds of revolt will continue to shake the foundations of our nation until the bright day of justice emerges.

But there is something that I must say to my people who stand on the warm threshold which leads into the palace of justice. In the process of gaining our rightful place, we must not be guilty of wrongful deeds. Let us not seek to satisfy our thirst for freedom by drinking from the cup of bitterness and hatred.

Bayard Rustin: The Man Behind the March on Washington (2021)
THROUGHLINE
Bayard Rustin: The Man Behind the March on Washington (2021)
We must forever conduct our struggle on the high plane of dignity and discipline. We must not allow our creative protest to degenerate into physical violence. Again and again, we must rise to the majestic heights of meeting physical force with soul force. The marvelous new militancy which has engulfed the Negro community must not lead us to a distrust of all white people, for many of our white brothers, as evidenced by their presence here today, have come to realize that their destiny is tied up with our destiny.

And they have come to realize that their freedom is inextricably bound to our freedom. We cannot walk alone. And as we walk, we must make the pledge that we shall always march ahead. We cannot turn back.

There are those who are asking the devotees of civil rights, when will you be satisfied? We can never be satisfied as long as the Negro is the victim of the unspeakable horrors of police brutality. We can never be satisfied as long as our bodies, heavy with the fatigue of travel, cannot gain lodging in the motels of the highways and the hotels of the cities.

We cannot be satisfied as long as the Negro's basic mobility is from a smaller ghetto to a larger one. We can never be satisfied as long as our children are stripped of their selfhood and robbed of their dignity by signs stating: for whites only.

We cannot be satisfied as long as a Negro in Mississippi cannot vote and a Negro in New York believes he has nothing for which to vote.

No, no, we are not satisfied, and we will not be satisfied until justice rolls down like waters, and righteousness like a mighty stream.

How The Voting Rights Act Came To Be And How It's Changed
POLITICS
How The Voting Rights Act Came To Be And How It's Changed
I am not unmindful that some of you have come here out of great trials and tribulations. Some of you have come fresh from narrow jail cells. Some of you have come from areas where your quest for freedom left you battered by the storms of persecution and staggered by the winds of police brutality. You have been the veterans of creative suffering. Continue to work with the faith that unearned suffering is redemptive. Go back to Mississippi, go back to Alabama, go back to South Carolina, go back to Georgia, go back to Louisiana, go back to the slums and ghettos of our Northern cities, knowing that somehow this situation can and will be changed.

Let us not wallow in the valley of despair, I say to you today, my friends.

So even though we face the difficulties of today and tomorrow, I still have a dream. It is a dream deeply rooted in the American dream. I have a dream that one day this nation will rise up and live out the true meaning of its creed: We hold these truths to be self-evident, that all men are created equal.


People clap and sing along to a freedom song between speeches at the March on Washington for Jobs and Freedom in 1963.
Express Newspapers via Getty Images
I have a dream that one day on the red hills of Georgia, the sons of former slaves and the sons of former slave owners will be able to sit down together at the table of brotherhood.

I have a dream that one day even the state of Mississippi, a state sweltering with the heat of injustice, sweltering with the heat of oppression will be transformed into an oasis of freedom and justice.

I have a dream that my four little children will one day live in a nation where they will not be judged by the color of their skin but by the content of their character. I have a dream today.

I have a dream that one day down in Alabama with its vicious racists, with its governor having his lips dripping with the words of interposition and nullification, one day right down in Alabama little Black boys and Black girls will be able to join hands with little white boys and white girls as sisters and brothers. I have a dream today.

I have a dream that one day every valley shall be exalted, every hill and mountain shall be made low, the rough places will be made plain, and the crooked places will be made straight, and the glory of the Lord shall be revealed, and all flesh shall see it together.

CODE SWITCH
Nikole Hannah-Jones on the power of collective memory
This is our hope. This is the faith that I go back to the South with. With this faith, we will be able to hew out of the mountain of despair a stone of hope. With this faith we will be able to transform the jangling discords of our nation into a beautiful symphony of brotherhood. With this faith we will be able to work together, to pray together, to struggle together, to go to jail together, to stand up for freedom together, knowing that we will be free one day.

This will be the day when all of God's children will be able to sing with new meaning: My country, 'tis of thee, sweet land of liberty, of thee I sing. Land where my fathers died, land of the pilgrims' pride, from every mountainside, let freedom ring.

And if America is to be a great nation, this must become true. And so let freedom ring from the prodigious hilltops of New Hampshire. Let freedom ring from the mighty mountains of New York. Let freedom ring from the heightening Alleghenies of Pennsylvania. Let freedom ring from the snowcapped Rockies of Colorado. Let freedom ring from the curvaceous slopes of California. But not only that, let freedom ring from Stone Mountain of Georgia. Let freedom ring from Lookout Mountain of Tennessee. Let freedom ring from every hill and molehill of Mississippi. From every mountainside, let freedom ring.

And when this happens, and when we allow freedom ring, when we let it ring from every village and every hamlet, from every state and every city, we will be able to speed up that day when all of God's children, Black men and white men, Jews and Gentiles, Protestants and Catholics, will be able to join hands and sing in the words of the old Negro spiritual: Free at last. Free at last. Thank God almighty, we are free at last.
from aiyc1v1 import DataManager, SimpleSearch
path = "/Users/huangjiabao/GitHub/MacBookPro16-Code/PythonCoder/StudentCoder/01_WillQX/Project/00/Prototypes-MP-GUI_Prototype/flask-server/python-src/Analysis.py"
data = DataManager(path).postfix()
from aiyc1v1 import Simple_NlP
# Sid = Simple_NlP(path="I_have_a_Dream.txt", filename="demo.html").main()

# num = 1.0
# print(type(num))
# print(num)


# str 字符串
str_content = "Hello AndersonHJB"
print(type(str_content))
# 见名知意
print(str_content)
# 1、有序性
# l    o    v    e  y    o    u
# 0    1    2    3456    7    8「从左到右」
# -9   -8   -7 -6-5-4-3  -2   -1  「从右到左」
# 下标
# 2、不可变性
# 3、任意数据类型/只要你键盘能输入的，都可以放入字符串中

# list 列表
lst = [1, "Austin", 2.0, "Jaden", (1, 2, 3, 4)]
# 1、有序性
# [1, "Austin", 2.0, "Jaden"]
#  0      1      2      3「从左到右」
# -4     -3     -2     -1 「从右到左」
# 2、可变性
# 列表被创建出来之后，可以被修改、删除、添加等操作
# 3、任意数据类型
# Python 的所有数据类型，均可放入。原本是什么类型，放进去后，还是什么类型——类似与于：书架
# n = 1

# 元组 tuple
t = (1, "Austin", 1.0, "book", [1, 2, 3, 4])
print(t)
print(type(t))
# 1、有序性
# 2、不可变
# 3、任意数据类型

# 字典 dict
d = {"name": "Austin", "age": 19, "key": "value"}
print(type(d))
print(d)
# 1、key: value
# 2、 key-> 钥匙🔑，能变形吗？-> 不能变形「不可变」：key 是要求不可变的数据类型
# 3、value 任意数据类型
# 4、无序的、python3.6+ 之后 字典是有序的，但是平时所说的有序，你目前用不到
# 1、列表、元组可以做key 吗？
# 2、真的 value 是任意数据类型吗？
d = {(1, 2, 3, 4): "list", "name": "AndersonHJB", 1: 12, "name1": [1, 2, 3]}
print(d)

# set 集合
s = {1, 2, 2, 2, 2, 2, 4, 6, (1, 2)}
print(s)
# 1、确定性
# 2、互异性
# 3、无序性
# PS：列表可变，可变造就了未知性与可变性
lst = [1, 2, 3, 3, 3, 4, 5, 6, 7]
s = set(lst)
print(s)

t = tuple(lst)
print(t)

string = str(lst)
print(string)

# d = dict(lst)
lst = [("name", "Austin"), ("age", 19)]
d = dict(lst)
print(d)

# 布尔型 bool
bool_true = True
bool_false = False
print(bool_false)
print(bool_true)

a = 91























print(a // 10 + a % 10)
print(a % 10 * 10 + a // 10)

# a = 1
# print(a + 10)
# print(a)
# a = a + 10
# print(a)
a = 1
a = a + 10
print(a)

b = 1
b += 10  # b = b + 10
print(b)

a = 1
b = 1
r = a + b
print(r)

a = 1.0
b = 1
r = a + b
print(r)

a = 2.0
b = 1
r = a - b
print(r)

a = 2
b = 1
r = a - b
print(r)

a = 2
b = 1
r = a * b
print(r)

a = 2
b = 1
r = a / b
print(r)
# print(a / b)
# print((1 + 1.0))

# a = 25
# Q1: 个位和十位相加 -> 2 + 5 = 7
# Q2: 25 52、41 14
# Q3: 在三位数的情况下，如何处理

a = 25
gewei = a % 10
shiwei = a // 10
r = gewei + shiwei
print(r)
print(gewei, shiwei, sep="", end="")  # 形，用不到这个 value，同时输出
# 你要用到 52，用的了
revers = gewei * 10 + shiwei
print(revers)
r = revers + 1
print(r)











boolean_1 = 1
boolean_2 = 2
r = boolean_2 > boolean_1
print(r)

print(boolean_2 < boolean_1)
print(1 < 2)
print(1 == 1)

import re

html = '''<div id="songs-list">
    <h2 class="title">经典老歌</h2>
    <p class="introduction">
        经典老歌列表
    </p>
    <ul id="list" class="list-group">
        <li data-view="2">一路上有你</li>
        <li data-view="7">
            <a href="/2.mp3" singer="任贤齐">沧海一声笑</a>
        </li>
        <li data-view="4" class="active">
            <a href="/3.mp3" singer="齐秦">往事随风</a>
        </li>
        <li data-view="6"><a href="/4.mp3" singer="beyond">光辉岁月</a></li>
        <li data-view="5"><a href="/5.mp3" singer="陈慧琳">记事本</a></li>
        <li data-view="5">
            <a href="/6.mp3" singer="邓丽君"><i class="fa fa-user"></i>但愿人长久</a>
        </li>
    </ul>
</div>'''
# pattern = '<li.*?active.*?singer="(\w+)">(\w+)</a>'
pattern = '<a.*?>(?:<i.*?</i>)*(.*?)</a>'
result = re.findall(pattern, html, re.S)
# result = re.search('<li.*?active.*?singer="(.*?)">(.*?)</a>', html, re.S)
# print(result.groups())
if result:
    for i in result:
        print(i)
#     # print(result.group(1, 2))

import requests
import re
from requests.exceptions import RequestException
from urllib.parse import urljoin

BASE = "https://bornforthis.cn/web_runing/crawler/regex/"


def requests_fun(url, binary=False):
    try:
        response = requests.get(url)
        if response.status_code == 200:
            if binary:
                return response.content
            else:
                return response.text
        return None
    except RequestException as e:
        return None


def save_music(path, binary):
    with open(path, "wb") as f:
        f.write(binary)


def parse(html):
    pattern = '<a.*?href="(.*?)".*?</a>'
    result = re.findall(pattern, html)
    return result


def joint(url_lst):
    url_list = []
    for url in url_lst:
        url = urljoin(BASE, url)
        url_list.append(url)
    return url_list


def postfix(url):
    music_name = url.split("/")[-1]
    return music_name


def main():
    url = "https://bornforthis.cn/web_runing/crawler/regex/index.html"
    html = requests_fun(url)
    # url_lst = parse(html)
    url_list = joint(parse(html))
    # print(url_list)
    for url in url_list:
        # print(url)
        binary_content = requests_fun(url, binary=True)
        # print(binary_content)
        save_music(f"data/music/{postfix(url)}", binary_content)


if __name__ == '__main__':
    main()






import random

player01_name = input("请输入玩家1号的名称")
player02_name = input("请输入玩家2号的名称")


# ----------------玩家初始信息------------------
class player():
    def __init__(self):
        self.health_point = 500

    def Attack_judge(self, name):
        input_text = True
        while input_text:
            attack_pattern = input(f"{name}请输入想要攻击的方式，输入“攻击”或者“防守”")
            if attack_pattern == "攻击" or "防守":
                input_text = False
            else:
                print("输入有误，请重新输入")
        return attack_pattern


player01 = player()
player02 = player()

# ---------------初始化---------------------
print("游戏即将开始。")
print(f"第一回合内{player01_name}，{player01_name}可以选择攻击或者防御，当选择防御时，{player01_name}在下一回合受到的攻击为实际伤害的十分之一")
print(f"首先请{player01_name}开始攻击")
i = True
while i:
    if player01.health_point <= 0 or player02.health_point <= 0:
        i = False
    else:
        attack_pattern_01 = player01.Attack_judge(player01_name)
        attack_pattern_02 = player02.Attack_judge(player02_name)
        # ---------------判断----------------
        # ---------------玩家1防御玩家2攻击-----------------
        if attack_pattern_01 == "防御" and attack_pattern_02 == "攻击":
            damage_02 = random.randint(50, 100)
            player01_name.health_point -= damage_02 // 10
            print(f"当前{player01_name}的血量为{player01.health_point}\n{player02_name}的血量为{player02.health_point}")
        # ---------------玩家1攻击玩家2防守-----------------
        elif attack_pattern_02 == "防御" and attack_pattern_01 == "攻击":
            damage_01 = random.randint(50, 100)
            player02.health_point -= damage_01 // 10
            print(f"当前{player01_name}的血量为{player01.health_point}\n{player02_name}的血量为{player02.health_point}")
        # ---------------玩家1攻击玩家2攻击-----------------
        elif attack_pattern_01 == "攻击" and attack_pattern_02 == "攻击":
            damage_01 = random.randint(50, 100)
            damage_02 = random.randint(50, 100)
            player01.health_point -= damage_02
            player02.health_point -= damage_01
            print(f"当前{player01_name}的血量为{player01.health_point}\n{player02_name}的血量为{player02.health_point}")
        # --------------玩家1防御玩家2防御------------------
        else:
            print("此轮攻击未造成双方血量减少")
# ---------------结果--------------
if player01.health_point <= 0 or player02.health_point >= 0:
    print(f"{player02_name}获胜。")
elif player01.health_point >= 0 or player02.health_point <= 0:
    print(f"{player01_name}获胜。")
else:
    print("双方平局")

import random

player01_name = input("请输入玩家1号的名称")
player02_name = input("请输入玩家2号的名称")


# ----------------玩家初始信息------------------
class player():
    def __init__(self):
        self.health_point = 100

    def Attack_or_Defence(self, name):
        input_text = True
        while input_text:
            attack_pattern = input(f"{name}请输入想要A的方式，输入“A”或者“D”")
            if attack_pattern == "A" or "D":
                input_text = False
            else:
                print("输入有误，请重新输入")
        return attack_pattern


# def Attack_or_Defence(name):
#     input_text = True
#     while input_text:
#         attack_pattern = input(f"{name}请输入想要A的方式，输入“A”或者“D”")
#         if attack_pattern == "A" or "D":
#             input_text = False
#         else:
#             print("输入有误，请重新输入")
#     return attack_pattern


player01 = player()
player02 = player()

# ---------------初始化---------------------
print("游戏即将开始。")
print(
    f"第一回合内{player01_name}，{player01_name}可以选择A或者防御，当选择防御时，{player01_name}在下一回合受到的A为实际伤害的十分之一")
print(f"首先请{player01_name}开始A")
i = True
while i:
    if player01.health_point <= 0 or player02.health_point <= 0:
        i = False
    damage = random.randint(50, 100)
    # attack_pattern_01 = Attack_or_Defence(player01_name)
    # attack_pattern_02 = Attack_or_Defence(player02_name)
    attack_pattern_01 = player01.Attack_or_Defence(name=player01_name)
    attack_pattern_02 = player01.Attack_or_Defence(name=player02_name)
    # input_text = True
    # while input_text:
    #     attack_pattern_01 = input(f"{player01_name}请输入想要A的方式，输入“A”或者“D”")
    #     if attack_pattern_01 == "A" or "D":
    #         input_text = False
    #     else:
    #         print("输入有误，请重新输入")
    # input_text = True
    # while input_text:
    #     attack_pattern_02 = input(f"{player02_name}请输入想要A的方式，输入“A”或者“D”")
    #     if attack_pattern_02 == "A" or "D":
    #         input_text = False
    #     else:
    #         print("输入有误，请重新输入")
    # ---------------判断----------------
    # ---------------玩家1防御玩家2A-----------------
    if attack_pattern_01 == "D" and attack_pattern_02 == "A":
        damage_02 = random.randint(50, 100)
        player01_name.health_point -= damage_02 // 10
        print(f"当前{player01_name}的血量为{player01.health_point}\n{player02_name}的血量为{player02.health_point}")
    # ---------------玩家1A玩家2D-----------------
    elif attack_pattern_02 == "防御" and attack_pattern_01 == "A":
        damage_01 = random.randint(50, 100)
        player02.health_point -= damage_01 // 10
        print(f"当前{player01_name}的血量为{player01.health_point}\n{player02_name}的血量为{player02.health_point}")
    # ---------------玩家1A玩家2A-----------------
    elif attack_pattern_01 == "A" and attack_pattern_02 == "A":
        damage_01 = random.randint(50, 100)
        damage_02 = random.randint(50, 100)
        player01.health_point -= damage_02
        player02.health_point -= damage_01
        print(f"当前{player01_name}的血量为{player01.health_point}\n{player02_name}的血量为{player02.health_point}")
    # --------------玩家1防御玩家2防御------------------
    else:
        print("此轮A未造成双方血量减少")
# ---------------结果--------------
if player01.health_point <= 0 or player02.health_point >= 0:
    print(f"{player02_name}获胜。")
elif player01.health_point >= 0 or player02.health_point <= 0:
    print(f"{player01_name}获胜。")
else:
    print("双方平局")


class Animals():
    def __init__(self):
        self.x = 0
dog = Animals()
print(dog.x)
import random

player01 = input("请输入玩家1号的名称")
player02 = input("请输入玩家2号的名称")


# ----------------玩家初始信息------------------
class player():
    def __init__(self):
        self.health_point = 500


player01 = player()
player02 = player()

# ---------------初始化---------------------
print("游戏即将开始。")
print(f"第一回合内{player01}，{player01}可以选择攻击或者防御，当选择防御时，{player01}在下一回合受到的攻击为实际伤害的十分之一")
print(f"首先请{player01}开始攻击")
i = True
while i:
    if player01.health_point <= 0 or player02.health_point <= 0:
        i = False
    damage = random.randint(50, 100)
    input_text = True
    while input_text:
        attack_pattern_01 = input(f"{player01}请输入想要攻击的方式，输入“攻击”或者“防守”")
        if attack_pattern_01 == "攻击" or "防守":
            input_text = False
        else:
            print("输入有误，请重新输入")
    input_text = True
    while input_text:
        attack_pattern_02 = input(f"{player02}请输入想要攻击的方式，输入“攻击”或者“防守”")
        if attack_pattern_02 == "攻击" or "防守":
            input_text = False
        else:
            print("输入有误，请重新输入")
    # ---------------判断----------------
    # ---------------玩家1防御玩家2攻击-----------------
    if attack_pattern_01 == "防御" and attack_pattern_02 == "攻击":
        damage_02 = random.randint(50, 100)
        player01.health_point -= damage_02 // 10
        print(f"当前{player01}的血量为"
              f"{player01.health_point}\n{player02}"
              f"的血量为{player02.health_point}")
    # ---------------玩家1攻击玩家2防守-----------------
    elif attack_pattern_02 == "防御" and attack_pattern_01 == "攻击":
        damage_01 = random.randint(50, 100)
        player02.health_point -= damage_01 // 10
        print(f"当前{player01}的血量为{player01.health_point}\n{player02}的血量为{player02.health_point}")
    # ---------------玩家1攻击玩家2攻击-----------------
    elif attack_pattern_01 == "攻击" and attack_pattern_02 == "攻击":
        damage_01 = random.randint(50, 100)
        damage_02 = random.randint(50, 100)
        player01.health_point -= damage_02
        player02.health_point -= damage_01
        print(f"当前{player01}的血量为{player01.health_point}\n{player02}的血量为{player02.health_point}")
    # --------------玩家1防御玩家2防御------------------
    else:
        print("此轮攻击未造成双方血量减少")

# author: look
import random

player01_name = input("请输入玩家1号的名称")
player02_name = input("请输入玩家2号的名称")


# ----------------玩家初始信息------------------
class player():
    def __init__(self):
        self.health_point = 500


player01 = player()  # 实例化
player02 = player()

# ---------------初始化---------------------
print("游戏即将开始。")
print(f"第一回合内{player01}，{player01}可以选择攻击或者防御，当选择防御时，{player01}在下一回合受到的攻击为实际伤害的十分之一")
print(f"首先请{player01}开始攻击")
i = True
while i:
    if player01.health_point <= 0 or player02.health_point <= 0:
        i = False
    damage = random.randint(50, 100)
    input_text = True
    while input_text:
        attack_pattern_01 = input(f"{player01}请输入想要攻击的方式，输入“攻击”或者“防守”")
        if attack_pattern_01 == "攻击" or "防守":
            input_text = False
        else:
            print("输入有误，请重新输入")
    input_text = True
    while input_text:
        attack_pattern_02 = input(f"{player02}请输入想要攻击的方式，输入“攻击”或者“防守”")
        if attack_pattern_02 == "攻击" or "防守":
            input_text = False
        else:
            print("输入有误，请重新输入")
    # ---------------判断----------------
    # ---------------玩家1防御玩家2攻击-----------------
    if attack_pattern_01 == "防御" and attack_pattern_02 == "攻击":
        damage_02 = random.randint(50, 100)
        player01.health_point -= damage_02 // 10
        print(f"当前{player01}的血量为{player01.health_point}\n{player02}的血量为{player02.health_point}")
    # ---------------玩家1攻击玩家2防守-----------------
    elif attack_pattern_02 == "防御" and attack_pattern_01 == "攻击":
        damage_01 = random.randint(50, 100)
        player02.health_point -= damage_01 // 10
        print(f"当前{player01}的血量为{player01.health_point}\n{player02}的血量为{player02.health_point}")
    # ---------------玩家1攻击玩家2攻击-----------------
    elif attack_pattern_01 == "攻击" and attack_pattern_02 == "攻击":
        damage_01 = random.randint(50, 100)
        damage_02 = random.randint(50, 100)
        player01.health_point -= damage_02
        player02.health_point -= damage_01
        print(f"当前{player01}的血量为{player01.health_point}\n{player02}的血量为{player02.health_point}")
    # --------------玩家1防御玩家2防御------------------
    else:
        print("此轮攻击未造成双方血量减少")
# ---------------结果--------------
if player01.health_point <= 0 or player02.health_point >= 0:
    print(f"{player02}获胜。")
elif player01.health_point >= 0 or player02.health_point <= 0:
    print(f"{player01}获胜。")
else:
    print("双方平局")


import platform
import os
import sys
import time


def main():
    content = "你好，我是悦创。。。"
    while True:
        # 清理屏幕输出
        if platform.system().lower() == "windows":
            os.system("cls")
        elif 'ipykernel' in sys.modules:
            from IPython.display import clear_output as clear
            clear()
        else:
            os.system("clear")
        print(content)
        # 休眠 300 毫秒
        time.sleep(0.3)
        content = content[1:] + content[0]


if __name__ == '__main__':
    main()

# 文字对话
# 1、玩家、敌人
# 2、攻击值是随机的
# 3、判断输赢
# 4、玩家可以选择攻击或者防守，防守受到敌人攻击值的 1/10
# 5、显示生命值
# 6、显示玩家 and 敌人名称
# 7、获取输入来进行操作
import random

PLAYER_NAME = "Austin"
ENEMY_NAME = "Jaden"
PLAYER_HP = 100
ENEMY_HP = 80


def attack_value():
    attack_value = random.randint(0, 50)
    return attack_value


def not_dead(hp):
    if hp >= 0:
        return True
    else:
        return False


def being_attack(hp, attack_value):
    hp = hp - attack_value
    return hp


def show_status(name, hp):
    # print(self.hp)
    # print(f"{self.name}' hp is {self.hp}")
    print("{}' hp is {}".format(name, hp))


def win_or_lose(hp):
    if hp > 0:
        print("You Win!")
    else:
        print("You Lose!")


def main():
    global PLAYER_HP, ENEMY_HP
    while not_dead(PLAYER_HP) and not_dead(ENEMY_HP):
        show_status(PLAYER_NAME, PLAYER_HP)
        show_status(ENEMY_NAME, ENEMY_HP)
        user_operation = input("Attack or Defence(A/D):>>>")
        if user_operation.upper() == "A":
            player_attack_value = attack_value()  # 获取攻击值的操作
            enemy_attack_value = attack_value()  # 获取攻击值的操作
            PLAYER_HP = being_attack(PLAYER_HP, enemy_attack_value)
            ENEMY_HP = being_attack(ENEMY_HP, player_attack_value)
        elif user_operation.upper() == "D":
            enemy_attack_value = attack_value() * 0.1  # 获取攻击值的操作
            PLAYER_HP = being_attack(PLAYER_HP, enemy_attack_value)
        else:
            print("请输入 A or D......")
    win_or_lose(PLAYER_HP)


if __name__ == '__main__':
    main()

# 文字对话
# 1、玩家、敌人
# 2、攻击值是随机的
# 3、判断输赢
# 4、玩家可以选择攻击或者防守，防守受到敌人攻击值的 1/10
# 5、显示生命值
# 6、显示玩家 and 敌人名称
# 7、获取输入来进行操作
import random


class Creature():
    def __init__(self, hp, name):
        self.hp = hp
        self.name = name

    def attack(self):
        """
        :return: attack_value
        return-type: random number
        """
        attack_value = random.randint(0, 50)
        # print("attack_value:>>>", attack_value)
        return attack_value

    def not_dead(self):
        # pass
        if self.hp >= 0:
            return True
        else:
            return False

    def being_attack(self, attack_value):
        self.hp = self.hp - attack_value

    def show_status(self):
        # print(self.hp)
        # print(f"{self.name}' hp is {self.hp}")
        print("{}' hp is {}".format(self.name, self.hp))

    def win_or_lose(self):
        if self.not_dead():
            print("You Win!")
        else:
            print("Lose!")


Player = Creature(hp=100, name="Austin")  # 实例化
Enemy = Creature(hp=80, name="Jaden")

while Player.not_dead() and Enemy.not_dead():
    Player.show_status()
    Enemy.show_status()

    user_operation = input("Attack or Defence(A/D):>>>")
    if user_operation.upper() == "A":
        Player_attack_value = Player.attack()  # 获取攻击值的操作
        Enemy_attack_value = Enemy.attack()
        Player.being_attack(Enemy_attack_value)
        Enemy.being_attack(Player_attack_value)
    elif user_operation.upper() == "D":
        Enemy_attack_value = Enemy.attack() * 0.1
        Player.being_attack(Enemy_attack_value)

Player.win_or_lose()

1. 什么是 HTMLHTML 称为超文本标记语言，
是一种标识性的语言。它包括一系列标签。
通过这些标签可以将网络上的文档格式统一，
使分散的 Internet 资源连接为一个逻辑整体。
超
文本是一种组织信息的方式，
它通过超级链接方法将文本中的文字、图表与其他信息媒体相关联。
这些相互关联的信息媒体可能在同一文本中，也可能是其他文件，
或是地理位置相距遥远的某台计算机上的文件。这种组织信息方式将分布在不同位置的信息资源用随机方式进行连接，
为人们查找，检索信息提供方便。#
------
著作权归黄家宝|AI悦创所有
原文链接：https://bornforthis.cn/column/web/book/html-01.html
lst = [1, 2, 3, 4, 5]
userinput = input(":>>>").split(" ")
# a = 1
lst[int(userinput[0]):int(userinput[0])] = [userinput[1]]
print(lst)



Python is an object-oriented programming language
import random
from faker import Faker


# 游戏的完成
# 随机生成敌人名称
# 自定义玩家名称
# 扩展：要求特殊神通：一键回血，副作用：敌人攻击值加倍
class Creature():
    def __init__(self, hp, name=Faker().name()):
        self.hp = hp
        self.name = name
        # self.faker = Faker()
        self.beishu = 1

    def attack(self):
        """
        function: 生成随机攻击值
        :return:
        """
        attack_value = random.randint(0, 50)
        return attack_value

    def not_dead(self):
        if self.hp > 0:
            return True
        else:
            return False

    def being_attack(self, attack_value):
        self.hp = self.hp - attack_value * self.beishu

    def show_status(self):
        # print(self.hp)
        print(f"{self.name}' hp is {self.hp}.")

    def hp_update(self):
        self.hp = 100
        self.beishu = 2


def main():
    player = Creature(100, "Austin")
    enemy = Creature(80)
    while player.not_dead() and enemy.not_dead():
        player.show_status()
        enemy.show_status()
        user_operation = input("Attack or Defence(A or D):>>>").upper()
        if user_operation == "A":
            player_attack_value = player.attack()
            enemy_attack_value = enemy.attack()
            player.being_attack(enemy_attack_value)
            enemy.being_attack(player_attack_value)
        elif user_operation == "D":
            enemy_attack_value = enemy.attack() * 0.1
            player.being_attack(enemy_attack_value)
        elif user_operation == "666":
            s = "请确认您的操作，这将把你的血量恢复至 100\n敌人攻击值将提升两倍。\n取消请输入 No，确认直接 enter or yes:"
            u = input(s)
            if u == "" or u.lower() == "yes":
                player.hp_update()
            else:
                print("您已经取消恢复血量......\n祝您好运！")
                # pass

    if player.not_dead():
        print("You Win.")
    else:
        print("You lose.")


if __name__ == '__main__':
    main()

look


import os

PATH = "."


def postfix(path):
    postfix_lst = ["zip", "rar", "jpg", "parquet", "xlsx", "xls",
                   "png", "ico", "docx"]
    suffix = path.split(".")[-1].lower()
    if suffix not in postfix_lst:
        return path
    else:
        return None


def generate_path(path):
    path_lst = []
    for dirpath, dirnames, filenames in os.walk(path):
        # print(dirpath, dirnames, filenames)
        for filename in filenames:
            path = dirpath + "/" + filename
            # print(path)
            # return path
            path_lst.append(path)
    return path_lst


def open_file(path_lst):
    for path in path_lst:
        print(f"Now Operation file-path:>>>{path}")
        r_path = postfix(path)
        if r_path is not None:
            with open(r_path, "r", encoding="utf-8") as f:
                content = f.read()
                print(content)
                print("-" * 10)
        else:
            pass


def main():
    path_lst = generate_path(PATH)
    # print(path)
    open_file(path_lst)


if __name__ == '__main__':
    main()


aiyc
aiyc2
aiyc
aiyc

from aiyc1v1 import SimpleSearch
ss = SimpleSearch()
ss.main()
1. 什么是 HTMLHTML 称为超文本标记语言，
是一种标识性的语言。它包括一系列标签。
通过这些标签可以将网络上的文档格式统一，
使分散的 Internet 资源连接为一个逻辑整体。
超
文本是一种组织信息的方式，
它通过超级链接方法将文本中的文字、图表与其他信息媒体相关联。
这些相互关联的信息媒体可能在同一文本中，也可能是其他文件，
或是地理位置相距遥远的某台计算机上的文件。这种组织信息方式将分布在不同位置的信息资源用随机方式进行连接，
为人们查找，检索信息提供方便。#
------
著作权归黄家宝|AI悦创所有
原文链接：https://bornforthis.cn/column/web/book/html-01.html



# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in your browser.

The page will reload when you make changes.\
You may also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can't go back!**

If you aren't satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you're on your own.

You don't have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn't feel obligated to use this feature. However we understand that this tool wouldn't be useful if you couldn't customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

### Code Splitting

This section has moved here: [https://facebook.github.io/create-react-app/docs/code-splitting](https://facebook.github.io/create-react-app/docs/code-splitting)

### Analyzing the Bundle Size

This section has moved here: [https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size](https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size)

### Making a Progressive Web App

This section has moved here: [https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app](https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app)

### Advanced Configuration

This section has moved here: [https://facebook.github.io/create-react-app/docs/advanced-configuration](https://facebook.github.io/create-react-app/docs/advanced-configuration)

### Deployment

This section has moved here: [https://facebook.github.io/create-react-app/docs/deployment](https://facebook.github.io/create-react-app/docs/deployment)

### `npm run build` fails to minify

This section has moved here: [https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify](https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify)





from flask import Flask
from flask import render_template
from flask import request

# import sys
# sys.path.append('../')

import Analysis
import test

app = Flask(__name__)


# default route
@app.route("/")
def index():
    return render_template('index.html')

# Ingestdata
@app.route("/upload", methods=['GET', 'POST'])
def dataIngestion():
    if request.method == 'POST':
        lfile = request.files['file']
        return lfile.filename
    return "A get method was launched"

@app.route("/plotGraph", methods=['GET', 'POST'])
def plotGraph():
    if request.method == 'POST':
        localFile = request.form['text']
        print(localFile)
        localJSON = prepareCSV(localFile)

        
        return localJSON

if __name__ == "__main__":
    app.run(debug=True)
import statistics as stats
import numpy as np
import pandas as pd
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler


class Analysis:

    def __init__(self):
        print("Analysis instance created")

    def perform_DR(self, df, threshold):
        # Algorithm determination?
        df = df.dropna()
        d = self.remove_chars(df)
        d['numbers'] = self.normalize_scale(d['numbers'])
        d['numbers'] = self.perform_pca(d['numbers'], threshold)

        new_df = pd.concat([d['chars'].iloc[0:d['numbers'].shape[0], :], d['numbers']], axis=1)

        print("Dimensionality reduction complete")
        print(str(df.shape[1]), "features compressed to", str(new_df.shape[1]),
              "containing", str(d['numbers'].shape[1]), "principle components")

        d['chars'] = d['chars'].reset_index(drop=True)
        d['numbers'] = d['numbers'].reset_index(drop=True)

        return d

    def perform_pca(self, df, threshold):

        # Run PCA once to find optimal n_components
        pca_1 = PCA(n_components=df.shape[1])
        comps = pca_1.fit_transform(df)
        var = pca_1.explained_variance_

        ideal = float(0)
        i = 0

        # Use minimum variables to reach threshold
        while ideal < (sum(var) * threshold):
            ideal = ideal + var[i]
            i = i + 1

        # Re-run PCA with i number of components
        pca = pd.DataFrame(PCA(n_components=i).fit_transform(df))

        s = []
        for x in range(1, i + 1):
            s.append(str("PrincipleC" + str(x)))

        pca.columns = s

        return pca

    def normalize_scale(self, df):
        scaler = StandardScaler()
        return pd.DataFrame(scaler.fit_transform(df))

    def remove_chars(self, df):

        d = {}  # holds 2 dataframes
        chars = []  # holds bool array

        for col in range(0, df.shape[1]):
            if df.dtypes[col] != 'float64' and df.dtypes[col] != 'int64':
                chars.append(True)
            else:
                chars.append(False)

        d['chars'] = df.loc[:, chars]
        chars = np.invert(chars)
        d['numbers'] = df.loc[:, chars]

        return d  # return dict with 2 tables

        """
        result = df.dtypes
        columns_to_remove = []

        for i in range(0, len(df.columns)):
            if result[i] == object:
                columns_to_remove.append(df.columns[i])

        for col in columns_to_remove:
            df.drop(col, inplace=True, axis=1)
        return df
        """

    def variable_analysis(self, df):
        """Perform basic variable analysis, returns a list of dataclass variables
        Should be used by main function not self
        """

        result = {}

        i = 0
        data = pd.DataFrame()
        names = []
        for x in df.dtypes:
            if x == 'float64' or x == 'int64':
                pd.concat([data, df.iloc[:, i]])
                names.append(df.columns[i])
                i = i + 1

        for x in range(0, data.shape[1]):
            s = {}
            d = data.iloc[:, x]
            s['name'] = names.pop()
            s['sd'] = stats.stdev(d)
            s['mean'] = stats.mean(d)
            s['max'] = max(d)
            s['min'] = min(d)
            result[s['name']] = s

        return result

import pandas as pd
import numpy as np

def prepareCSV(file):
    df = pd.read_csv(file)
    df = df.loc[:, ['Period','Data_value']]
    return df.to_json()
import statistics as stats
import numpy as np
import pandas as pd
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler


class Analysis:

    def __init__(self):
        print("Analysis instance created")

        # Split object values
        # remove nan values
        # normalize scale
        # perform pca

    def perform_DR(self, df, threshold):
        # Algorithm determination?
        df = df.dropna()
        d = self.remove_chars(df)
        d['numbers'] = self.normalize_scale(d['numbers'])
        d['numbers'] = self.perform_pca(d['numbers'], threshold)

        new_df = pd.concat([d['chars'].iloc[0:d['numbers'].shape[0], :], d['numbers']], axis=1)

        print("Dimensionality reduction complete")
        print(str(df.shape[1]), "features compressed to", str(new_df.shape[1]),
              "containing", str(d['numbers'].shape[1]), "principle components")


        return new_df

    def perform_pca(self, df, threshold):

        # Run PCA once to find optimal n_components
        pca_1 = PCA(n_components=df.shape[1])
        comps = pca_1.fit_transform(df)
        var = pca_1.explained_variance_

        ideal = float(0)
        i = 0

        # Use minimum variables to reach threshold
        while ideal < (sum(var) * threshold):
            ideal = ideal + var[i]
            i = i + 1

        # Re-run PCA with i number of components
        pca = pd.DataFrame(PCA(n_components=i).fit_transform(df))

        s = []
        for x in range(1, i + 1):
            s.append(str("PrincipleC" + str(x)))

        pca.columns = s

        return pca

    def normalize_scale(self, df):
        scaler = StandardScaler()
        return pd.DataFrame(scaler.fit_transform(df))

    def remove_chars(self, df):

        d = {}  # holds 2 dataframes
        chars = []  # holds bool array

        for col in range(0, df.shape[1]):
            if df.dtypes[col] != 'float64' and df.dtypes[col] != 'int64':
                chars.append(True)
            else:
                chars.append(False)

        d['chars'] = df.loc[:, chars]
        chars = np.invert(chars)
        d['numbers'] = df.loc[:, chars]

        return d  # return dict with 2 tables

        """
        result = df.dtypes
        columns_to_remove = []

        for i in range(0, len(df.columns)):
            if result[i] == object:
                columns_to_remove.append(df.columns[i])

        for col in columns_to_remove:
            df.drop(col, inplace=True, axis=1)
        return df
        """

    def variable_analysis(self, df):
        """Perform basic variable analysis, returns a list of dataclass variables
        Should be used by main function not self
        """

        result = {}

        i = 0
        data = pd.DataFrame()
        names = []
        for x in df.dtypes:
            if x == 'float64' or x == 'int64':
                data.append(df.iloc[:, i])
                names.append(df.columns[i])
                i = i + 1

        for x in range(0, data.shape[1]):
            s = {}
            d = data.iloc[:, x]
            s['name'] = names.pop()
            s['sd'] = stats.stdev(d)
            s['mean'] = stats.mean(d)
            s['max'] = max(d)
            s['min'] = min(d)
            result[s['name']] = s

        return result

import pandas as pd
import os
import sys


# Class DataManager version 1

class DataManager:
    def __init__(self):
        try:
            self.df = pd.DataFrame()
        except:
            print("Failed to initialize Data Reader")

    def ReadFile(self, path):

        # Code for reading from the path
        try:
            x = path.split(".", 1)[1].lower()
        except:
            print("Insufficient file path")

        if (x == "csv"):
            self.InjectCSV(path)
        elif (x == "xlsx" or x == "xls"):
            self.InjectEXCEL(path)
        elif (x == "parquet"):
            self.InjectPARQUET(path)
        elif (x == "txt"):
            self.InjectTXT(path)
        elif (x == "json"):
            self.InjectJSON(path)
        else:
            print("Unsupported filetype")

        return self.df
        # A gate similar to switch state in order to call correct function
        # Else statement if none of   the common functions appliable

    # A bunch of function to read data depending on extension
    def InjectCSV(self, path):
        try:
            self.df = pd.read_csv(path)
        except Exception as e:
            print("Failed to CSV inject data: ", e)

    def InjectEXCEL(self, path):
        try:
            self.df = pd.read_excel(path)
        except Exception as e:
            print("Failed to EXCEL inject data: ", e)

    def InjectTXT(self, path):
        try:
            self.df = pd.read_fwf(path)
        except Exception as e:
            print("Failed to TXT inject data: ", e)

    def InjectPARQUET(self, path):
        try:
            self.df = pd.read_parquet(path)
        except Exception as e:
            print("Failed to PARQUET inject data: ", e)

    def InjectJSON(self, path):
        try:
            self.df = pd.read_json(path)
        except Exception as e:
            print("Failed to JSON inject data: ", e)

    # Function to output Data
    def OutputDataEXCEL(self, df, path):
        try:
            if not df.empty:
                df.to_excel(path)
        except Exception as e:
            print("Failed to write a file: ", e)

if __name__ == '__main__':
    data = DataManager()   # 类的是例化
    data.ReadFile("/Users/huangjiabao/GitHub/MacBookPro16-Code/PythonCoder/StudentCoder/01_WillQX/Prototypes-MP-GUI_Prototype/test.csv")
    print(data.df)
import unittest


class MyTestCase(unittest.TestCase):
    def test_something(self):
        self.assertEqual(True, False)  # add assertion here


if __name__ == '__main__':
    unittest.main()


import os
import sys

root_folder = os.path.abspath(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
sys.path.append(root_folder)

import DataManager as di
# Test code

d = di.DataManager()
filepathCSV = root_folder+"/Testing/IngestionTesting/test.csv"
filepathEXCEL_OLD = root_folder+"/Testing/IngestionTesting/test.xls"
filepathEXCEL_NEW = root_folder+"/Testing/IngestionTesting/test.xlsx"
filepathTXT = root_folder+"/Testing/IngestionTesting/test.txt"
filepathPARQUET = root_folder+"/Testing/IngestionTesting/test.parquet"
filepathJSON = root_folder+"/Testing/IngestionTesting/test.json"

df_csv = d.ReadFile(filepathCSV)
df_excel_old = d.ReadFile(filepathEXCEL_OLD)
df_excel_new = d.ReadFile(filepathEXCEL_NEW)
df_txt = d.ReadFile(filepathTXT)
df_parquet = d.ReadFile(filepathPARQUET)
df_json = d.ReadFile(filepathJSON)


d.OutputDataEXCEL(df_json, root_folder+"/Testing/IngestionTesting/testOutput.xlsx")

if df_csv.empty:
    print("CSV Import failed")
else:
    print("CSV Import Success") 

if df_excel_old.empty:
    print("EXCEL-OLD Import failed")
else:
    print("EXCEL-OLD Import Success") 
    
if df_excel_new.empty:
    print("EXCEL-NEW Import failed")
else:
    print("EXCEL-NEW Import Success") 

if df_txt.empty:
    print("TXT Import failed")
else:
    print("TXT Import Success") 

if df_parquet.empty:
    print("PARQUET Import failed")
else:
    print("PARQUET Import Success") 

if df_json.empty:
    print("JSON Import failed")
else:
    print("JSON Import Success") 





Read Martin Luther King Jr.'s 'I Have a Dream' speech in its entirety
Updated January 14, 20221:53 PM ET
Heard on Talk of the Nation
17-Minute Listen
Download
Transcript

Civil rights leader Martin Luther King Jr. addresses the crowd at the Lincoln Memorial in Washington, D.C., where he gave his "I Have a Dream" speech on Aug. 28, 1963, as part of the March on Washington.
AFP via Getty Images
Monday marks the birthday of Martin Luther King Jr. Below is a transcript of his celebrated "I Have a Dream" speech, delivered on Aug. 28, 1963, on the steps of the Lincoln Memorial. NPR's Talk of the Nation aired the speech in 2010 — listen to that broadcast at the audio link above.


Martin Luther King Jr. and other civil rights leaders gather before a rally at the Lincoln Memorial on Aug. 28, 1963, in Washington.
National Archives/Hulton Archive via Getty Images
Rev. Martin Luther King Jr.: Five score years ago, a great American, in whose symbolic shadow we stand today, signed the Emancipation Proclamation. This momentous decree came as a great beacon light of hope to millions of Negro slaves who had been seared in the flames of withering injustice. It came as a joyous daybreak to end the long night of their captivity.

But 100 years later, the Negro still is not free. One hundred years later, the life of the Negro is still sadly crippled by the manacles of segregation and the chains of discrimination. One hundred years later, the Negro lives on a lonely island of poverty in the midst of a vast ocean of material prosperity. One hundred years later the Negro is still languished in the corners of American society and finds himself in exile in his own land. And so we've come here today to dramatize a shameful condition. In a sense we've come to our nation's capital to cash a check.

The Power Of Martin Luther King Jr.'s Anger
CODE SWITCH
The Power Of Martin Luther King Jr.'s Anger
When the architects of our republic wrote the magnificent words of the Constitution and the Declaration of Independence, they were signing a promissory note to which every American was to fall heir. This note was a promise that all men — yes, Black men as well as white men — would be guaranteed the unalienable rights of life, liberty and the pursuit of happiness.

It is obvious today that America has defaulted on this promissory note insofar as her citizens of color are concerned. Instead of honoring this sacred obligation, America has given the Negro people a bad check, a check which has come back marked insufficient funds.

But we refuse to believe that the bank of justice is bankrupt.

We refuse to believe that there are insufficient funds in the great vaults of opportunity of this nation. And so we've come to cash this check, a check that will give us upon demand the riches of freedom and the security of justice.

We have also come to his hallowed spot to remind America of the fierce urgency of now. This is no time to engage in the luxury of cooling off or to take the tranquilizing drug of gradualism.


Civil rights protesters march from the Washington Monument to the Lincoln Memorial for the March on Washington on Aug. 28, 1963.
Kurt Severin/Three Lions/Hulton Archive/Getty Images
Now is the time to make real the promises of democracy. Now is the time to rise from the dark and desolate valley of segregation to the sunlit path of racial justice. Now is the time to lift our nation from the quick sands of racial injustice to the solid rock of brotherhood. Now is the time to make justice a reality for all of God's children.

It would be fatal for the nation to overlook the urgency of the moment. This sweltering summer of the Negro's legitimate discontent will not pass until there is an invigorating autumn of freedom and equality. 1963 is not an end, but a beginning. Those who hope that the Negro needed to blow off steam and will now be content will have a rude awakening if the nation returns to business as usual.

There will be neither rest nor tranquility in America until the Negro is granted his citizenship rights. The whirlwinds of revolt will continue to shake the foundations of our nation until the bright day of justice emerges.

But there is something that I must say to my people who stand on the warm threshold which leads into the palace of justice. In the process of gaining our rightful place, we must not be guilty of wrongful deeds. Let us not seek to satisfy our thirst for freedom by drinking from the cup of bitterness and hatred.

Bayard Rustin: The Man Behind the March on Washington (2021)
THROUGHLINE
Bayard Rustin: The Man Behind the March on Washington (2021)
We must forever conduct our struggle on the high plane of dignity and discipline. We must not allow our creative protest to degenerate into physical violence. Again and again, we must rise to the majestic heights of meeting physical force with soul force. The marvelous new militancy which has engulfed the Negro community must not lead us to a distrust of all white people, for many of our white brothers, as evidenced by their presence here today, have come to realize that their destiny is tied up with our destiny.

And they have come to realize that their freedom is inextricably bound to our freedom. We cannot walk alone. And as we walk, we must make the pledge that we shall always march ahead. We cannot turn back.

There are those who are asking the devotees of civil rights, when will you be satisfied? We can never be satisfied as long as the Negro is the victim of the unspeakable horrors of police brutality. We can never be satisfied as long as our bodies, heavy with the fatigue of travel, cannot gain lodging in the motels of the highways and the hotels of the cities.

We cannot be satisfied as long as the Negro's basic mobility is from a smaller ghetto to a larger one. We can never be satisfied as long as our children are stripped of their selfhood and robbed of their dignity by signs stating: for whites only.

We cannot be satisfied as long as a Negro in Mississippi cannot vote and a Negro in New York believes he has nothing for which to vote.

No, no, we are not satisfied, and we will not be satisfied until justice rolls down like waters, and righteousness like a mighty stream.

How The Voting Rights Act Came To Be And How It's Changed
POLITICS
How The Voting Rights Act Came To Be And How It's Changed
I am not unmindful that some of you have come here out of great trials and tribulations. Some of you have come fresh from narrow jail cells. Some of you have come from areas where your quest for freedom left you battered by the storms of persecution and staggered by the winds of police brutality. You have been the veterans of creative suffering. Continue to work with the faith that unearned suffering is redemptive. Go back to Mississippi, go back to Alabama, go back to South Carolina, go back to Georgia, go back to Louisiana, go back to the slums and ghettos of our Northern cities, knowing that somehow this situation can and will be changed.

Let us not wallow in the valley of despair, I say to you today, my friends.

So even though we face the difficulties of today and tomorrow, I still have a dream. It is a dream deeply rooted in the American dream. I have a dream that one day this nation will rise up and live out the true meaning of its creed: We hold these truths to be self-evident, that all men are created equal.


People clap and sing along to a freedom song between speeches at the March on Washington for Jobs and Freedom in 1963.
Express Newspapers via Getty Images
I have a dream that one day on the red hills of Georgia, the sons of former slaves and the sons of former slave owners will be able to sit down together at the table of brotherhood.

I have a dream that one day even the state of Mississippi, a state sweltering with the heat of injustice, sweltering with the heat of oppression will be transformed into an oasis of freedom and justice.

I have a dream that my four little children will one day live in a nation where they will not be judged by the color of their skin but by the content of their character. I have a dream today.

I have a dream that one day down in Alabama with its vicious racists, with its governor having his lips dripping with the words of interposition and nullification, one day right down in Alabama little Black boys and Black girls will be able to join hands with little white boys and white girls as sisters and brothers. I have a dream today.

I have a dream that one day every valley shall be exalted, every hill and mountain shall be made low, the rough places will be made plain, and the crooked places will be made straight, and the glory of the Lord shall be revealed, and all flesh shall see it together.

CODE SWITCH
Nikole Hannah-Jones on the power of collective memory
This is our hope. This is the faith that I go back to the South with. With this faith, we will be able to hew out of the mountain of despair a stone of hope. With this faith we will be able to transform the jangling discords of our nation into a beautiful symphony of brotherhood. With this faith we will be able to work together, to pray together, to struggle together, to go to jail together, to stand up for freedom together, knowing that we will be free one day.

This will be the day when all of God's children will be able to sing with new meaning: My country, 'tis of thee, sweet land of liberty, of thee I sing. Land where my fathers died, land of the pilgrims' pride, from every mountainside, let freedom ring.

And if America is to be a great nation, this must become true. And so let freedom ring from the prodigious hilltops of New Hampshire. Let freedom ring from the mighty mountains of New York. Let freedom ring from the heightening Alleghenies of Pennsylvania. Let freedom ring from the snowcapped Rockies of Colorado. Let freedom ring from the curvaceous slopes of California. But not only that, let freedom ring from Stone Mountain of Georgia. Let freedom ring from Lookout Mountain of Tennessee. Let freedom ring from every hill and molehill of Mississippi. From every mountainside, let freedom ring.

And when this happens, and when we allow freedom ring, when we let it ring from every village and every hamlet, from every state and every city, we will be able to speed up that day when all of God's children, Black men and white men, Jews and Gentiles, Protestants and Catholics, will be able to join hands and sing in the words of the old Negro spiritual: Free at last. Free at last. Thank God almighty, we are free at last.
from aiyc1v1 import DataManager, SimpleSearch
path = "/Users/huangjiabao/GitHub/MacBookPro16-Code/PythonCoder/StudentCoder/01_WillQX/Project/00/Prototypes-MP-GUI_Prototype/flask-server/python-src/Analysis.py"
data = DataManager(path).postfix()
from aiyc1v1 import Simple_NlP
# Sid = Simple_NlP(path="I_have_a_Dream.txt", filename="demo.html").main()

# num = 1.0
# print(type(num))
# print(num)


# str 字符串
str_content = "Hello AndersonHJB"
print(type(str_content))
# 见名知意
print(str_content)
# 1、有序性
# l    o    v    e  y    o    u
# 0    1    2    3456    7    8「从左到右」
# -9   -8   -7 -6-5-4-3  -2   -1  「从右到左」
# 下标
# 2、不可变性
# 3、任意数据类型/只要你键盘能输入的，都可以放入字符串中

# list 列表
lst = [1, "Austin", 2.0, "Jaden", (1, 2, 3, 4)]
# 1、有序性
# [1, "Austin", 2.0, "Jaden"]
#  0      1      2      3「从左到右」
# -4     -3     -2     -1 「从右到左」
# 2、可变性
# 列表被创建出来之后，可以被修改、删除、添加等操作
# 3、任意数据类型
# Python 的所有数据类型，均可放入。原本是什么类型，放进去后，还是什么类型——类似与于：书架
# n = 1

# 元组 tuple
t = (1, "Austin", 1.0, "book", [1, 2, 3, 4])
print(t)
print(type(t))
# 1、有序性
# 2、不可变
# 3、任意数据类型

# 字典 dict
d = {"name": "Austin", "age": 19, "key": "value"}
print(type(d))
print(d)
# 1、key: value
# 2、 key-> 钥匙🔑，能变形吗？-> 不能变形「不可变」：key 是要求不可变的数据类型
# 3、value 任意数据类型
# 4、无序的、python3.6+ 之后 字典是有序的，但是平时所说的有序，你目前用不到
# 1、列表、元组可以做key 吗？
# 2、真的 value 是任意数据类型吗？
d = {(1, 2, 3, 4): "list", "name": "AndersonHJB", 1: 12, "name1": [1, 2, 3]}
print(d)

# set 集合
s = {1, 2, 2, 2, 2, 2, 4, 6, (1, 2)}
print(s)
# 1、确定性
# 2、互异性
# 3、无序性
# PS：列表可变，可变造就了未知性与可变性
lst = [1, 2, 3, 3, 3, 4, 5, 6, 7]
s = set(lst)
print(s)

t = tuple(lst)
print(t)

string = str(lst)
print(string)

# d = dict(lst)
lst = [("name", "Austin"), ("age", 19)]
d = dict(lst)
print(d)

# 布尔型 bool
bool_true = True
bool_false = False
print(bool_false)
print(bool_true)

a = 91























print(a // 10 + a % 10)
print(a % 10 * 10 + a // 10)

# a = 1
# print(a + 10)
# print(a)
# a = a + 10
# print(a)
a = 1
a = a + 10
print(a)

b = 1
b += 10  # b = b + 10
print(b)

a = 1
b = 1
r = a + b
print(r)

a = 1.0
b = 1
r = a + b
print(r)

a = 2.0
b = 1
r = a - b
print(r)

a = 2
b = 1
r = a - b
print(r)

a = 2
b = 1
r = a * b
print(r)

a = 2
b = 1
r = a / b
print(r)
# print(a / b)
# print((1 + 1.0))

# a = 25
# Q1: 个位和十位相加 -> 2 + 5 = 7
# Q2: 25 52、41 14
# Q3: 在三位数的情况下，如何处理

a = 25
gewei = a % 10
shiwei = a // 10
r = gewei + shiwei
print(r)
print(gewei, shiwei, sep="", end="")  # 形，用不到这个 value，同时输出
# 你要用到 52，用的了
revers = gewei * 10 + shiwei
print(revers)
r = revers + 1
print(r)











boolean_1 = 1
boolean_2 = 2
r = boolean_2 > boolean_1
print(r)

print(boolean_2 < boolean_1)
print(1 < 2)
print(1 == 1)

import re

html = '''<div id="songs-list">
    <h2 class="title">经典老歌</h2>
    <p class="introduction">
        经典老歌列表
    </p>
    <ul id="list" class="list-group">
        <li data-view="2">一路上有你</li>
        <li data-view="7">
            <a href="/2.mp3" singer="任贤齐">沧海一声笑</a>
        </li>
        <li data-view="4" class="active">
            <a href="/3.mp3" singer="齐秦">往事随风</a>
        </li>
        <li data-view="6"><a href="/4.mp3" singer="beyond">光辉岁月</a></li>
        <li data-view="5"><a href="/5.mp3" singer="陈慧琳">记事本</a></li>
        <li data-view="5">
            <a href="/6.mp3" singer="邓丽君"><i class="fa fa-user"></i>但愿人长久</a>
        </li>
    </ul>
</div>'''
# pattern = '<li.*?active.*?singer="(\w+)">(\w+)</a>'
pattern = '<a.*?>(?:<i.*?</i>)*(.*?)</a>'
result = re.findall(pattern, html, re.S)
# result = re.search('<li.*?active.*?singer="(.*?)">(.*?)</a>', html, re.S)
# print(result.groups())
if result:
    for i in result:
        print(i)
#     # print(result.group(1, 2))

import requests
import re
from requests.exceptions import RequestException
from urllib.parse import urljoin

BASE = "https://bornforthis.cn/web_runing/crawler/regex/"


def requests_fun(url, binary=False):
    try:
        response = requests.get(url)
        if response.status_code == 200:
            if binary:
                return response.content
            else:
                return response.text
        return None
    except RequestException as e:
        return None


def save_music(path, binary):
    with open(path, "wb") as f:
        f.write(binary)


def parse(html):
    pattern = '<a.*?href="(.*?)".*?</a>'
    result = re.findall(pattern, html)
    return result


def joint(url_lst):
    url_list = []
    for url in url_lst:
        url = urljoin(BASE, url)
        url_list.append(url)
    return url_list


def postfix(url):
    music_name = url.split("/")[-1]
    return music_name


def main():
    url = "https://bornforthis.cn/web_runing/crawler/regex/index.html"
    html = requests_fun(url)
    # url_lst = parse(html)
    url_list = joint(parse(html))
    # print(url_list)
    for url in url_list:
        # print(url)
        binary_content = requests_fun(url, binary=True)
        # print(binary_content)
        save_music(f"data/music/{postfix(url)}", binary_content)


if __name__ == '__main__':
    main()






import random

player01_name = input("请输入玩家1号的名称")
player02_name = input("请输入玩家2号的名称")


# ----------------玩家初始信息------------------
class player():
    def __init__(self):
        self.health_point = 500

    def Attack_judge(self, name):
        input_text = True
        while input_text:
            attack_pattern = input(f"{name}请输入想要攻击的方式，输入“攻击”或者“防守”")
            if attack_pattern == "攻击" or "防守":
                input_text = False
            else:
                print("输入有误，请重新输入")
        return attack_pattern


player01 = player()
player02 = player()

# ---------------初始化---------------------
print("游戏即将开始。")
print(f"第一回合内{player01_name}，{player01_name}可以选择攻击或者防御，当选择防御时，{player01_name}在下一回合受到的攻击为实际伤害的十分之一")
print(f"首先请{player01_name}开始攻击")
i = True
while i:
    if player01.health_point <= 0 or player02.health_point <= 0:
        i = False
    else:
        attack_pattern_01 = player01.Attack_judge(player01_name)
        attack_pattern_02 = player02.Attack_judge(player02_name)
        # ---------------判断----------------
        # ---------------玩家1防御玩家2攻击-----------------
        if attack_pattern_01 == "防御" and attack_pattern_02 == "攻击":
            damage_02 = random.randint(50, 100)
            player01_name.health_point -= damage_02 // 10
            print(f"当前{player01_name}的血量为{player01.health_point}\n{player02_name}的血量为{player02.health_point}")
        # ---------------玩家1攻击玩家2防守-----------------
        elif attack_pattern_02 == "防御" and attack_pattern_01 == "攻击":
            damage_01 = random.randint(50, 100)
            player02.health_point -= damage_01 // 10
            print(f"当前{player01_name}的血量为{player01.health_point}\n{player02_name}的血量为{player02.health_point}")
        # ---------------玩家1攻击玩家2攻击-----------------
        elif attack_pattern_01 == "攻击" and attack_pattern_02 == "攻击":
            damage_01 = random.randint(50, 100)
            damage_02 = random.randint(50, 100)
            player01.health_point -= damage_02
            player02.health_point -= damage_01
            print(f"当前{player01_name}的血量为{player01.health_point}\n{player02_name}的血量为{player02.health_point}")
        # --------------玩家1防御玩家2防御------------------
        else:
            print("此轮攻击未造成双方血量减少")
# ---------------结果--------------
if player01.health_point <= 0 or player02.health_point >= 0:
    print(f"{player02_name}获胜。")
elif player01.health_point >= 0 or player02.health_point <= 0:
    print(f"{player01_name}获胜。")
else:
    print("双方平局")

import random

player01_name = input("请输入玩家1号的名称")
player02_name = input("请输入玩家2号的名称")


# ----------------玩家初始信息------------------
class player():
    def __init__(self):
        self.health_point = 100

    def Attack_or_Defence(self, name):
        input_text = True
        while input_text:
            attack_pattern = input(f"{name}请输入想要A的方式，输入“A”或者“D”")
            if attack_pattern == "A" or "D":
                input_text = False
            else:
                print("输入有误，请重新输入")
        return attack_pattern


# def Attack_or_Defence(name):
#     input_text = True
#     while input_text:
#         attack_pattern = input(f"{name}请输入想要A的方式，输入“A”或者“D”")
#         if attack_pattern == "A" or "D":
#             input_text = False
#         else:
#             print("输入有误，请重新输入")
#     return attack_pattern


player01 = player()
player02 = player()

# ---------------初始化---------------------
print("游戏即将开始。")
print(
    f"第一回合内{player01_name}，{player01_name}可以选择A或者防御，当选择防御时，{player01_name}在下一回合受到的A为实际伤害的十分之一")
print(f"首先请{player01_name}开始A")
i = True
while i:
    if player01.health_point <= 0 or player02.health_point <= 0:
        i = False
    damage = random.randint(50, 100)
    # attack_pattern_01 = Attack_or_Defence(player01_name)
    # attack_pattern_02 = Attack_or_Defence(player02_name)
    attack_pattern_01 = player01.Attack_or_Defence(name=player01_name)
    attack_pattern_02 = player01.Attack_or_Defence(name=player02_name)
    # input_text = True
    # while input_text:
    #     attack_pattern_01 = input(f"{player01_name}请输入想要A的方式，输入“A”或者“D”")
    #     if attack_pattern_01 == "A" or "D":
    #         input_text = False
    #     else:
    #         print("输入有误，请重新输入")
    # input_text = True
    # while input_text:
    #     attack_pattern_02 = input(f"{player02_name}请输入想要A的方式，输入“A”或者“D”")
    #     if attack_pattern_02 == "A" or "D":
    #         input_text = False
    #     else:
    #         print("输入有误，请重新输入")
    # ---------------判断----------------
    # ---------------玩家1防御玩家2A-----------------
    if attack_pattern_01 == "D" and attack_pattern_02 == "A":
        damage_02 = random.randint(50, 100)
        player01_name.health_point -= damage_02 // 10
        print(f"当前{player01_name}的血量为{player01.health_point}\n{player02_name}的血量为{player02.health_point}")
    # ---------------玩家1A玩家2D-----------------
    elif attack_pattern_02 == "防御" and attack_pattern_01 == "A":
        damage_01 = random.randint(50, 100)
        player02.health_point -= damage_01 // 10
        print(f"当前{player01_name}的血量为{player01.health_point}\n{player02_name}的血量为{player02.health_point}")
    # ---------------玩家1A玩家2A-----------------
    elif attack_pattern_01 == "A" and attack_pattern_02 == "A":
        damage_01 = random.randint(50, 100)
        damage_02 = random.randint(50, 100)
        player01.health_point -= damage_02
        player02.health_point -= damage_01
        print(f"当前{player01_name}的血量为{player01.health_point}\n{player02_name}的血量为{player02.health_point}")
    # --------------玩家1防御玩家2防御------------------
    else:
        print("此轮A未造成双方血量减少")
# ---------------结果--------------
if player01.health_point <= 0 or player02.health_point >= 0:
    print(f"{player02_name}获胜。")
elif player01.health_point >= 0 or player02.health_point <= 0:
    print(f"{player01_name}获胜。")
else:
    print("双方平局")


class Animals():
    def __init__(self):
        self.x = 0
dog = Animals()
print(dog.x)
import random

player01 = input("请输入玩家1号的名称")
player02 = input("请输入玩家2号的名称")


# ----------------玩家初始信息------------------
class player():
    def __init__(self):
        self.health_point = 500


player01 = player()
player02 = player()

# ---------------初始化---------------------
print("游戏即将开始。")
print(f"第一回合内{player01}，{player01}可以选择攻击或者防御，当选择防御时，{player01}在下一回合受到的攻击为实际伤害的十分之一")
print(f"首先请{player01}开始攻击")
i = True
while i:
    if player01.health_point <= 0 or player02.health_point <= 0:
        i = False
    damage = random.randint(50, 100)
    input_text = True
    while input_text:
        attack_pattern_01 = input(f"{player01}请输入想要攻击的方式，输入“攻击”或者“防守”")
        if attack_pattern_01 == "攻击" or "防守":
            input_text = False
        else:
            print("输入有误，请重新输入")
    input_text = True
    while input_text:
        attack_pattern_02 = input(f"{player02}请输入想要攻击的方式，输入“攻击”或者“防守”")
        if attack_pattern_02 == "攻击" or "防守":
            input_text = False
        else:
            print("输入有误，请重新输入")
    # ---------------判断----------------
    # ---------------玩家1防御玩家2攻击-----------------
    if attack_pattern_01 == "防御" and attack_pattern_02 == "攻击":
        damage_02 = random.randint(50, 100)
        player01.health_point -= damage_02 // 10
        print(f"当前{player01}的血量为"
              f"{player01.health_point}\n{player02}"
              f"的血量为{player02.health_point}")
    # ---------------玩家1攻击玩家2防守-----------------
    elif attack_pattern_02 == "防御" and attack_pattern_01 == "攻击":
        damage_01 = random.randint(50, 100)
        player02.health_point -= damage_01 // 10
        print(f"当前{player01}的血量为{player01.health_point}\n{player02}的血量为{player02.health_point}")
    # ---------------玩家1攻击玩家2攻击-----------------
    elif attack_pattern_01 == "攻击" and attack_pattern_02 == "攻击":
        damage_01 = random.randint(50, 100)
        damage_02 = random.randint(50, 100)
        player01.health_point -= damage_02
        player02.health_point -= damage_01
        print(f"当前{player01}的血量为{player01.health_point}\n{player02}的血量为{player02.health_point}")
    # --------------玩家1防御玩家2防御------------------
    else:
        print("此轮攻击未造成双方血量减少")

# author: look
import random

player01_name = input("请输入玩家1号的名称")
player02_name = input("请输入玩家2号的名称")


# ----------------玩家初始信息------------------
class player():
    def __init__(self):
        self.health_point = 500


player01 = player()  # 实例化
player02 = player()

# ---------------初始化---------------------
print("游戏即将开始。")
print(f"第一回合内{player01}，{player01}可以选择攻击或者防御，当选择防御时，{player01}在下一回合受到的攻击为实际伤害的十分之一")
print(f"首先请{player01}开始攻击")
i = True
while i:
    if player01.health_point <= 0 or player02.health_point <= 0:
        i = False
    damage = random.randint(50, 100)
    input_text = True
    while input_text:
        attack_pattern_01 = input(f"{player01}请输入想要攻击的方式，输入“攻击”或者“防守”")
        if attack_pattern_01 == "攻击" or "防守":
            input_text = False
        else:
            print("输入有误，请重新输入")
    input_text = True
    while input_text:
        attack_pattern_02 = input(f"{player02}请输入想要攻击的方式，输入“攻击”或者“防守”")
        if attack_pattern_02 == "攻击" or "防守":
            input_text = False
        else:
            print("输入有误，请重新输入")
    # ---------------判断----------------
    # ---------------玩家1防御玩家2攻击-----------------
    if attack_pattern_01 == "防御" and attack_pattern_02 == "攻击":
        damage_02 = random.randint(50, 100)
        player01.health_point -= damage_02 // 10
        print(f"当前{player01}的血量为{player01.health_point}\n{player02}的血量为{player02.health_point}")
    # ---------------玩家1攻击玩家2防守-----------------
    elif attack_pattern_02 == "防御" and attack_pattern_01 == "攻击":
        damage_01 = random.randint(50, 100)
        player02.health_point -= damage_01 // 10
        print(f"当前{player01}的血量为{player01.health_point}\n{player02}的血量为{player02.health_point}")
    # ---------------玩家1攻击玩家2攻击-----------------
    elif attack_pattern_01 == "攻击" and attack_pattern_02 == "攻击":
        damage_01 = random.randint(50, 100)
        damage_02 = random.randint(50, 100)
        player01.health_point -= damage_02
        player02.health_point -= damage_01
        print(f"当前{player01}的血量为{player01.health_point}\n{player02}的血量为{player02.health_point}")
    # --------------玩家1防御玩家2防御------------------
    else:
        print("此轮攻击未造成双方血量减少")
# ---------------结果--------------
if player01.health_point <= 0 or player02.health_point >= 0:
    print(f"{player02}获胜。")
elif player01.health_point >= 0 or player02.health_point <= 0:
    print(f"{player01}获胜。")
else:
    print("双方平局")


import platform
import os
import sys
import time


def main():
    content = "你好，我是悦创。。。"
    while True:
        # 清理屏幕输出
        if platform.system().lower() == "windows":
            os.system("cls")
        elif 'ipykernel' in sys.modules:
            from IPython.display import clear_output as clear
            clear()
        else:
            os.system("clear")
        print(content)
        # 休眠 300 毫秒
        time.sleep(0.3)
        content = content[1:] + content[0]


if __name__ == '__main__':
    main()

# 文字对话
# 1、玩家、敌人
# 2、攻击值是随机的
# 3、判断输赢
# 4、玩家可以选择攻击或者防守，防守受到敌人攻击值的 1/10
# 5、显示生命值
# 6、显示玩家 and 敌人名称
# 7、获取输入来进行操作
import random

PLAYER_NAME = "Austin"
ENEMY_NAME = "Jaden"
PLAYER_HP = 100
ENEMY_HP = 80


def attack_value():
    attack_value = random.randint(0, 50)
    return attack_value


def not_dead(hp):
    if hp >= 0:
        return True
    else:
        return False


def being_attack(hp, attack_value):
    hp = hp - attack_value
    return hp


def show_status(name, hp):
    # print(self.hp)
    # print(f"{self.name}' hp is {self.hp}")
    print("{}' hp is {}".format(name, hp))


def win_or_lose(hp):
    if hp > 0:
        print("You Win!")
    else:
        print("You Lose!")


def main():
    global PLAYER_HP, ENEMY_HP
    while not_dead(PLAYER_HP) and not_dead(ENEMY_HP):
        show_status(PLAYER_NAME, PLAYER_HP)
        show_status(ENEMY_NAME, ENEMY_HP)
        user_operation = input("Attack or Defence(A/D):>>>")
        if user_operation.upper() == "A":
            player_attack_value = attack_value()  # 获取攻击值的操作
            enemy_attack_value = attack_value()  # 获取攻击值的操作
            PLAYER_HP = being_attack(PLAYER_HP, enemy_attack_value)
            ENEMY_HP = being_attack(ENEMY_HP, player_attack_value)
        elif user_operation.upper() == "D":
            enemy_attack_value = attack_value() * 0.1  # 获取攻击值的操作
            PLAYER_HP = being_attack(PLAYER_HP, enemy_attack_value)
        else:
            print("请输入 A or D......")
    win_or_lose(PLAYER_HP)


if __name__ == '__main__':
    main()

# 文字对话
# 1、玩家、敌人
# 2、攻击值是随机的
# 3、判断输赢
# 4、玩家可以选择攻击或者防守，防守受到敌人攻击值的 1/10
# 5、显示生命值
# 6、显示玩家 and 敌人名称
# 7、获取输入来进行操作
import random


class Creature():
    def __init__(self, hp, name):
        self.hp = hp
        self.name = name

    def attack(self):
        """
        :return: attack_value
        return-type: random number
        """
        attack_value = random.randint(0, 50)
        # print("attack_value:>>>", attack_value)
        return attack_value

    def not_dead(self):
        # pass
        if self.hp >= 0:
            return True
        else:
            return False

    def being_attack(self, attack_value):
        self.hp = self.hp - attack_value

    def show_status(self):
        # print(self.hp)
        # print(f"{self.name}' hp is {self.hp}")
        print("{}' hp is {}".format(self.name, self.hp))

    def win_or_lose(self):
        if self.not_dead():
            print("You Win!")
        else:
            print("Lose!")


Player = Creature(hp=100, name="Austin")  # 实例化
Enemy = Creature(hp=80, name="Jaden")

while Player.not_dead() and Enemy.not_dead():
    Player.show_status()
    Enemy.show_status()

    user_operation = input("Attack or Defence(A/D):>>>")
    if user_operation.upper() == "A":
        Player_attack_value = Player.attack()  # 获取攻击值的操作
        Enemy_attack_value = Enemy.attack()
        Player.being_attack(Enemy_attack_value)
        Enemy.being_attack(Player_attack_value)
    elif user_operation.upper() == "D":
        Enemy_attack_value = Enemy.attack() * 0.1
        Player.being_attack(Enemy_attack_value)

Player.win_or_lose()

1. 什么是 HTMLHTML 称为超文本标记语言，
是一种标识性的语言。它包括一系列标签。
通过这些标签可以将网络上的文档格式统一，
使分散的 Internet 资源连接为一个逻辑整体。
超
文本是一种组织信息的方式，
它通过超级链接方法将文本中的文字、图表与其他信息媒体相关联。
这些相互关联的信息媒体可能在同一文本中，也可能是其他文件，
或是地理位置相距遥远的某台计算机上的文件。这种组织信息方式将分布在不同位置的信息资源用随机方式进行连接，
为人们查找，检索信息提供方便。#
------
著作权归黄家宝|AI悦创所有
原文链接：https://bornforthis.cn/column/web/book/html-01.html
lst = [1, 2, 3, 4, 5]
userinput = input(":>>>").split(" ")
# a = 1
lst[int(userinput[0]):int(userinput[0])] = [userinput[1]]
print(lst)



Python is an object-oriented programming language
import random
from faker import Faker


# 游戏的完成
# 随机生成敌人名称
# 自定义玩家名称
# 扩展：要求特殊神通：一键回血，副作用：敌人攻击值加倍
class Creature():
    def __init__(self, hp, name=Faker().name()):
        self.hp = hp
        self.name = name
        # self.faker = Faker()
        self.beishu = 1

    def attack(self):
        """
        function: 生成随机攻击值
        :return:
        """
        attack_value = random.randint(0, 50)
        return attack_value

    def not_dead(self):
        if self.hp > 0:
            return True
        else:
            return False

    def being_attack(self, attack_value):
        self.hp = self.hp - attack_value * self.beishu

    def show_status(self):
        # print(self.hp)
        print(f"{self.name}' hp is {self.hp}.")

    def hp_update(self):
        self.hp = 100
        self.beishu = 2


def main():
    player = Creature(100, "Austin")
    enemy = Creature(80)
    while player.not_dead() and enemy.not_dead():
        player.show_status()
        enemy.show_status()
        user_operation = input("Attack or Defence(A or D):>>>").upper()
        if user_operation == "A":
            player_attack_value = player.attack()
            enemy_attack_value = enemy.attack()
            player.being_attack(enemy_attack_value)
            enemy.being_attack(player_attack_value)
        elif user_operation == "D":
            enemy_attack_value = enemy.attack() * 0.1
            player.being_attack(enemy_attack_value)
        elif user_operation == "666":
            s = "请确认您的操作，这将把你的血量恢复至 100\n敌人攻击值将提升两倍。\n取消请输入 No，确认直接 enter or yes:"
            u = input(s)
            if u == "" or u.lower() == "yes":
                player.hp_update()
            else:
                print("您已经取消恢复血量......\n祝您好运！")
                # pass

    if player.not_dead():
        print("You Win.")
    else:
        print("You lose.")


if __name__ == '__main__':
    main()

look


import os

PATH = "."


def postfix(path):
    postfix_lst = ["zip", "rar", "jpg", "parquet", "xlsx", "xls",
                   "png", "ico", "docx"]
    suffix = path.split(".")[-1].lower()
    if suffix not in postfix_lst:
        return path
    else:
        return None


def generate_path(path):
    path_lst = []
    for dirpath, dirnames, filenames in os.walk(path):
        # print(dirpath, dirnames, filenames)
        for filename in filenames:
            path = dirpath + "/" + filename
            # print(path)
            # return path
            path_lst.append(path)
    return path_lst


def open_file(path_lst):
    for path in path_lst:
        print(f"Now Operation file-path:>>>{path}")
        r_path = postfix(path)
        if r_path is not None:
            with open(r_path, "r", encoding="utf-8") as f:
                content = f.read()
                print(content)
                print("-" * 10)
        else:
            pass


def main():
    path_lst = generate_path(PATH)
    # print(path)
    open_file(path_lst)


if __name__ == '__main__':
    main()


aiyc
aiyc2
aiyc
aiyc

from aiyc1v1 import SimpleSearch
ss = SimpleSearch()
ss.main()
1. 什么是 HTMLHTML 称为超文本标记语言，
是一种标识性的语言。它包括一系列标签。
通过这些标签可以将网络上的文档格式统一，
使分散的 Internet 资源连接为一个逻辑整体。
超
文本是一种组织信息的方式，
它通过超级链接方法将文本中的文字、图表与其他信息媒体相关联。
这些相互关联的信息媒体可能在同一文本中，也可能是其他文件，
或是地理位置相距遥远的某台计算机上的文件。这种组织信息方式将分布在不同位置的信息资源用随机方式进行连接，
为人们查找，检索信息提供方便。#
------
著作权归黄家宝|AI悦创所有
原文链接：https://bornforthis.cn/column/web/book/html-01.html


